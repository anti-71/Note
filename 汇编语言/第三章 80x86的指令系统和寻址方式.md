# **第三章** **80x86**的指令系统和寻址方式

## 3.1 寻址方式

### 一、寻址方式总览

8086 与数据相关的寻址方式分 **7 类**，可归为**立即寻址、寄存器寻址、存储器寻址（5 种子类）**，覆盖从 “指令内直接给数” 到 “复杂内存地址计算” 的场景：

| 寻址方式         | 操作数位置                             | 核心特点                       | 示例指令               |
| ---------------- | -------------------------------------- | ------------------------------ | ---------------------- |
| 立即寻址         | 指令中直接包含操作数                   | 无需访问内存，速度快           | `MOV AX, 3069H`        |
| 寄存器寻址       | CPU 寄存器中                           | 访问速度快，依赖寄存器         | `MOV AL, BH`           |
| 直接寻址         | 内存中，地址由指令直接给出             | 地址显式写在指令，默认用 DS    | `MOV AX, [2000H]`      |
| 寄存器间接寻址   | 内存中，地址存于基址 / 变址寄存器      | 地址动态存寄存器，灵活寻址     | `MOV AX, [BX]`         |
| 寄存器相对寻址   | 内存中，地址 = 寄存器值 + 位移量       | 结合寄存器和固定偏移，适合数组 | `MOV AX, COUNT[SI]`    |
| 基址变址寻址     | 内存中，地址 = 基址寄存器 + 变址寄存器 | 双寄存器动态计算，灵活度高     | `MOV AX, [BP][DI]`     |
| 相对基址变址寻址 | 内存中，地址 = 基址 + 变址 + 位移量    | 三重组合，支持复杂内存定位     | `MOV AX, MASK[BX][SI]` |

### 二、逐类详解

#### 1. 立即寻址

**原理**：操作数直接嵌入指令，执行时无需访问内存

**限制**：

- 仅用于**源操作数（SRC）**，不能写目标操作数（DST）
- SRC和DST**字长必须一致**（如`MOV AH, 3064H` 非法，因`AH`是 8 位，`3064H`是 16 位）

#### 2. 寄存器寻址

**原理**：操作数存于 CPU 寄存器（如`AX`/`BX`/`AH`/`BH` 等 ），直接读写寄存器

**限制**：

- 字节寄存器仅`AH`/`AL`/`BH`/`BL`/`CH`/`CL`/`DH`/`DL`，字寄存器如`AX`/`BX` 等
- SRC和DST**字长必须一致**（如`MOV AH, BX` 非法，`AH`是 8 位，`BX`是 16 位 ）
- **CS寄存器不能用MOV指令修改**（如`MOV CS, AX` 非法 ）

#### 3. 直接寻址

**原理**：有效地址（EA）由指令直接给出（如`[2000H]` ），默认用**数据段（DS）** 寄存器计算物理地址（PA = 16d × DS + EA ）

**扩展与限制**：

- 可通过**段跨越前缀**指定其他段（如`MOV AX, ES:[2000H]` ，用附加段 ES ）
- 操作数地址可用**符号地址（变量名）** 表示（如`VALUE DB 10` ），但需注意字长匹配（如`MOV AX, VALUE` 非法，需用`WORD PTR` 显式指定字操作：`MOV AX, WORD PTR VALUE` ）

#### 4. 寄存器间接寻址

**原理**：有效地址（EA）存于**基址寄存器（BX/BP）**或**变址寄存器（SI/DI）**，物理地址计算分两种：

- 用`BX`/`SI`/`DI` 时，默认段为**DS**（PA = 16d × DS + 寄存器值 ）
- 用`BP` 时，默认段为**SS**（堆栈段，PA = 16d × SS + BP 值 ）

**限制**：

- 不能用`AX`/`CX`/`DX` 存 EA（如`MOV AX, [CX]` 非法 ）
- SRC和DST字长需一致（如`[BX]` 可指字节 / 字单元，由目标寄存器决定 ）

#### 5. 寄存器相对寻址

**原理**：有效地址（EA）= **基址 / 变址寄存器值 + 位移量**（位移量可为 8 位或 16 位，如`COUNT[SI]` 等价于`[COUNT+SI]` ）

**应用**：适合数组、字符串处理（位移量可对应数组起始偏移，寄存器对应下标 ）

#### 6. 基址变址寻址

**原理**：有效地址（EA）= **基址寄存器（BX/BP）值 + 变址寄存器（SI/DI）值**，需**一个基址 + 一个变址寄存器**组合（如`[BX][DI]` 合法，`[BX][BP]`/`[SI][DI]` 非法 ）

**应用**：灵活处理二维数组、表格（基址定行，变址定列 ）

#### 7. 相对基址变址寻址

**原理**：有效地址（EA）= **基址寄存器值 + 变址寄存器值 + 位移量**（三重组合，如`MASK[BX][SI]` ），支持更复杂的内存定位（如带偏移的二维数组 ）

### 三、**8086 处理器段寄存器使用规则表**

| 存储器访问场景       | 默认段寄存器 | 可跨越段寄存器 | 偏移地址来源   |
| -------------------- | ------------ | -------------- | -------------- |
| 取指令（执行程序）   | CS           | 无             | IP             |
| 堆栈操作（push/pop） | SS           | 无             | SP             |
| 一般数据访问         | DS           | CS、ES、SS     | EA（有效地址） |
| BP 作基址寻址        | SS           | CS、DS、ES     | BP             |
| 串操作源操作数       | DS           | CS、ES、SS     | SI             |
| 串操作目的操作数     | ES           | 无             | DI             |

### 四、80x86 新增的寻址方式

核心公式：**有效地址 EA = 基址寄存器 + 变址寄存器 × 比例因子 + 位移量**（比例因子为 1、2、4、8，适配字节、字、双字、四字数据宽度）

#### （1）比例变址寻址方式

**原理**：有效地址由 **位移量 + 变址寄存器 × 比例因子** 计算（基址寄存器可隐含为 0，即直接以位移为基地址 ）

示例：

```
MOV EAX, COUNT[ESI*4]
```

#### （2）基址比例变址寻址方式

**原理**：有效地址由 **基址寄存器 + 变址寄存器 × 比例因子** 计算（无位移量，基址寄存器直接提供数据起始地址 ）。

示例：

```
MOV ECX, [EAX][EDI*4]
```

#### （3）相对基址比例变址寻址方式

**原理**：有效地址由 **位移量 + 基址寄存器 + 变址寄存器 × 比例因子** 计算（三重组合，适配更复杂的内存布局 ）。

示例：

```
MOV EAX, TABLE[EBP][EDI*4]
```

### 五、与转移地址有关的寻址方式

用于确定**转移指令（如 JMP）和CALL 指令**的转向地址，分**段内寻址**（同一段，仅修改IP）和**段间寻址**（跨段，修改CS和IP）两类：

#### （1）段内直接寻址

**原理**：转向有效地址 = **当前 IP 值 + 位移量**（位移量为 8 位或 16 位，对应短转移 / 近转移 ）

**特点**：

- 位移量是指令到目标地址的**相对偏移**，汇编时计算
- 短转移（SHORT）：位移量 8 位，范围 `-128 ~ +127`；
- 近转移（NEAR PTR）：位移量 16 位，范围 `-32768 ~ +32767`

示例：

```assembly
JMP SHORT NEXT  ; 短转移，IP += 8位位移
JMP NEAR PTR NEXT ; 近转移，IP += 16位位移
NEXT: ret       ; 目标地址
```

#### （2）段内间接寻址

**原理**：转向有效地址**存于寄存器或内存单元**，通过数据寻址方式（除立即数外）获取

示例：

- 寄存器间接：`JMP BX` → IP = BX 的值（如 BX=1256H，则 IP=1256H ）

- 内存间接（结合数据寻址）：

  ```assembly
  ; 假设 TABLE=20A2H, DS=2000H, BX=1256H，内存232F8H（2000H+20A2H+1256H）存3280H
  JMP WORD PTR TABLE[BX]  ; IP = (232F8H) = 3280H
  ; 或基址变址：BX=1256H, SI=528EH，内存264E4H（2000H+1256H+528EH）存2450H
  JMP WORD PTR [BX][SI]   ; IP = (264E4H) = 2450H
  ```

#### （3）段间直接寻址

**原理**：指令直接提供 **新的段地址（改 CS）和偏移地址（改 IP）**，实现跨段跳转。

示例：

```assembly
; code1段跳转到code2段的next标签
code1 segment
    ...
    JMP FAR PTR next  ; CS = code2的段地址，IP = next的偏移地址
    ...
code1 ends

code2 segment
next: ...
code2 ends
```

#### （4）段间间接寻址

**原理**：从**内存连续两个字**中获取目标地址：低字→IP，高字→CS（需用`DWORD PTR`指定双字访问 ）

**约束**：内存地址需通过**非立即数、非寄存器**的数据寻址方式获取（如基址 + 变址 ）

示例：

```assembly
; INTERS是位移量，BX是变址，内存中连续双字：低字→IP，高字→CS
JMP DWORD PTR [INTERS + BX]
```

## 3.2、指令系统

### 一、数据传送指令

##### 1.通用数据传送指令

###### **（1）MOV 指令（数据传送）**

**格式**：`MOV DST, SRC`

**操作逻辑**：将源操作数 `SRC` 的内容复制到目的操作数 `DST`，即 `(DST) ← (SRC)`

**核心限制**：

- `DST` 不能是**CS（代码段寄存器）**（修改 CS 会直接改变程序执行流，风险高）；
- `DST` 和 `SRC` 不能**同时为段寄存器**（如 `MOV DS, ES` 非法）；
- **立即数不能直接写入段寄存器**（如 `MOV DS, 2000H` 非法，需通过通用寄存器中转，如 `MOV AX, 2000H` → `MOV DS, AX`）；
- `DST` 不能是**立即数**（目的必须是寄存器或内存单元）；
- `DST` 和 `SRC` 不能**同时为存储器寻址**（无法直接在两个内存单元间传送，需借助寄存器）

###### **堆栈基础**：

- 属于**堆栈段（SS）**的“**先进后出**”存储区，**SP 始终指向栈顶**（低地址端）；
- 操作单位为**字（2字节）**，高字节存高地址，低字节存低地址

###### **（2）PUSH 进栈指令**

**格式**：`PUSH SRC`

**执行步骤**：

1. **调整栈顶**：`SP ← SP - 2`（SP 向低地址移动，预留存储空间）；
2. **数据入栈**：将 `SRC` 的内容存入新栈顶（高字节写 `SP+1`，低字节写 `SP`），即 `((SP)+1, SP) ← SRC`

**限制**：

- 不能用**立即寻址**（如 `PUSH 1234H` 非法，需先存入寄存器）；
- 不影响标志位；
- `SRC` 可为通用寄存器、段寄存器（除 CS 外，因 `POP CS` 非法，故 `PUSH CS` 也需谨慎）

示例：若 `AX = 2107H`，执行 `PUSH AX`：

- SP 先减 2，然后 `21H`（高字节）存入 `SP+1`，`07H`（低字节）存入 `SP`，栈顶指向新 SP 位置

###### **（3）POP 出栈指令**

**格式**：`POP DST`

执行步骤：

1. **数据出栈**：将栈顶内容（`SP+1` 存高字节，`SP` 存低字节）传送到 `DST`，即 `DST ← ((SP)+1, SP)`；
2. **调整栈顶**：`SP ← SP + 2`（SP 向高地址移动，释放栈空间）。

**限制**：

- `DST` 不能是**CS**（修改 CS 会破坏程序执行流程，如 `POP CS` 非法）；
- 不影响标志位

**示例**：执行 `POP BX` 时，栈顶的 `2107H`（`SP+1=21H`，`SP=07H`）被传送到 BX，随后 SP 加 2

###### **（4）XCHG 交换指令**

**格式**：`XCHG OPR1, OPR2`

**操作逻辑**：两个操作数内容互换，即 `OPR1 ↔ OPR2`

**限制**：

- 不影响标志位；
- **不能使用段寄存器**（操作数只能是通用寄存器或内存单元）

示例：

- `XCHG BX, [BP+SI]`：寄存器 BX 与内存单元（BP+SI 寻址）交换数据；
- `XCHG AL, BH`：寄存器 AL 和 BH 交换内容

###### **应用场景补充**

- PUSH/POP常用于保护/恢复现场（如子程序调用时保存寄存器值，返回前恢复）：

  ```assembly
  PUSH AX    ; 保存AX
  PUSH BX    ; 保存BX
  ...        ; 子程序逻辑（使用AX、BX）
  POP BX     ; 恢复BX
  POP AX     ; 恢复AX
  ```

- **XCHG** 可快速交换数据，避免额外寄存器暂存，提升代码效率

##### 2.累加器专用传送指令

##### 3.地址传送指令

##### 4.标志寄存器传送指令

##### 5.类型转换指令



