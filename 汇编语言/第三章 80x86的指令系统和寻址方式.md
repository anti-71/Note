# **第三章** **80x86**的指令系统和寻址方式

## 3.1 寻址方式

### 一、寻址方式总览

8086 与数据相关的寻址方式分 **7 类**，可归为**立即寻址、寄存器寻址、存储器寻址（5 种子类）**，覆盖从 “指令内直接给数” 到 “复杂内存地址计算” 的场景：

| 寻址方式         | 操作数位置                             | 核心特点                       | 示例指令               |
| ---------------- | -------------------------------------- | ------------------------------ | ---------------------- |
| 立即寻址         | 指令中直接包含操作数                   | 无需访问内存，速度快           | `MOV AX, 3069H`        |
| 寄存器寻址       | CPU 寄存器中                           | 访问速度快，依赖寄存器         | `MOV AL, BH`           |
| 直接寻址         | 内存中，地址由指令直接给出             | 地址显式写在指令，默认用 DS    | `MOV AX, [2000H]`      |
| 寄存器间接寻址   | 内存中，地址存于基址 / 变址寄存器      | 地址动态存寄存器，灵活寻址     | `MOV AX, [BX]`         |
| 寄存器相对寻址   | 内存中，地址 = 寄存器值 + 位移量       | 结合寄存器和固定偏移，适合数组 | `MOV AX, COUNT[SI]`    |
| 基址变址寻址     | 内存中，地址 = 基址寄存器 + 变址寄存器 | 双寄存器动态计算，灵活度高     | `MOV AX, [BP][DI]`     |
| 相对基址变址寻址 | 内存中，地址 = 基址 + 变址 + 位移量    | 三重组合，支持复杂内存定位     | `MOV AX, MASK[BX][SI]` |

### 二、逐类详解

#### 1. 立即寻址

**原理**：操作数直接嵌入指令，执行时无需访问内存

**限制**：

- 仅用于**源操作数（SRC）**，不能写目标操作数（DST）
- SRC和DST**字长必须一致**（如`MOV AH, 3064H` 非法，因`AH`是 8 位，`3064H`是 16 位）

#### 2. 寄存器寻址

**原理**：操作数存于 CPU 寄存器（如`AX`/`BX`/`AH`/`BH` 等 ），直接读写寄存器

**限制**：

- 字节寄存器仅`AH`/`AL`/`BH`/`BL`/`CH`/`CL`/`DH`/`DL`，字寄存器如`AX`/`BX` 等
- SRC和DST**字长必须一致**（如`MOV AH, BX` 非法，`AH`是 8 位，`BX`是 16 位 ）
- **CS寄存器不能用MOV指令修改**（如`MOV CS, AX` 非法 ）

#### 3. 直接寻址

**原理**：有效地址（EA）由指令直接给出（如`[2000H]` ），默认用**数据段（DS）** 寄存器计算物理地址（PA = 16d × DS + EA ）

**扩展与限制**：

- 可通过**段跨越前缀**指定其他段（如`MOV AX, ES:[2000H]` ，用附加段 ES ）
- 操作数地址可用**符号地址（变量名）** 表示（如`VALUE DB 10` ），但需注意字长匹配（如`MOV AX, VALUE` 非法，需用`WORD PTR` 显式指定字操作：`MOV AX, WORD PTR VALUE` ）

#### 4. 寄存器间接寻址

**原理**：有效地址（EA）存于**基址寄存器（BX/BP）**或**变址寄存器（SI/DI）**，物理地址计算分两种：

- 用`BX`/`SI`/`DI` 时，默认段为**DS**（PA = 16d × DS + 寄存器值 ）
- 用`BP` 时，默认段为**SS**（堆栈段，PA = 16d × SS + BP 值 ）

**限制**：

- 不能用`AX`/`CX`/`DX` 存 EA（如`MOV AX, [CX]` 非法 ）
- SRC和DST字长需一致（如`[BX]` 可指字节 / 字单元，由目标寄存器决定 ）

#### 5. 寄存器相对寻址

**原理**：有效地址（EA）= **基址 / 变址寄存器值 + 位移量**（位移量可为 8 位或 16 位，如`COUNT[SI]` 等价于`[COUNT+SI]` ）

**应用**：适合数组、字符串处理（位移量可对应数组起始偏移，寄存器对应下标 ）

#### 6. 基址变址寻址

**原理**：有效地址（EA）= **基址寄存器（BX/BP）值 + 变址寄存器（SI/DI）值**，需**一个基址 + 一个变址寄存器**组合（如`[BX][DI]` 合法，`[BX][BP]`/`[SI][DI]` 非法 ）

**应用**：灵活处理二维数组、表格（基址定行，变址定列 ）

#### 7. 相对基址变址寻址

**原理**：有效地址（EA）= **基址寄存器值 + 变址寄存器值 + 位移量**（三重组合，如`MASK[BX][SI]` ），支持更复杂的内存定位（如带偏移的二维数组 ）

### 三、**8086 处理器段寄存器使用规则表**

| 存储器访问场景       | 默认段寄存器 | 可跨越段寄存器 | 偏移地址来源   |
| -------------------- | ------------ | -------------- | -------------- |
| 取指令（执行程序）   | CS           | 无             | IP             |
| 堆栈操作（push/pop） | SS           | 无             | SP             |
| 一般数据访问         | DS           | CS、ES、SS     | EA（有效地址） |
| BP 作基址寻址        | SS           | CS、DS、ES     | BP             |
| 串操作源操作数       | DS           | CS、ES、SS     | SI             |
| 串操作目的操作数     | ES           | 无             | DI             |

### 四、80x86 新增的寻址方式

核心公式：**有效地址 EA = 基址寄存器 + 变址寄存器 × 比例因子 + 位移量**（比例因子为 1、2、4、8，适配字节、字、双字、四字数据宽度）

#### （1）比例变址寻址方式

**原理**：有效地址由 **位移量 + 变址寄存器 × 比例因子** 计算（基址寄存器可隐含为 0，即直接以位移为基地址 ）

示例：

```
MOV EAX, COUNT[ESI*4]
```

#### （2）基址比例变址寻址方式

**原理**：有效地址由 **基址寄存器 + 变址寄存器 × 比例因子** 计算（无位移量，基址寄存器直接提供数据起始地址 ）

示例：

```
MOV ECX, [EAX][EDI*4]
```

#### （3）相对基址比例变址寻址方式

**原理**：有效地址由 **位移量 + 基址寄存器 + 变址寄存器 × 比例因子** 计算（三重组合，适配更复杂的内存布局 ）

示例：

```
MOV EAX, TABLE[EBP][EDI*4]
```

### 五、与转移地址有关的寻址方式

用于确定**转移指令（如 JMP）和CALL 指令**的转向地址，分**段内寻址**（同一段，仅修改IP）和**段间寻址**（跨段，修改CS和IP）两类：

#### （1）段内直接寻址

**原理**：转向有效地址 = **当前 IP 值 + 位移量**（位移量为 8 位或 16 位，对应短转移 / 近转移 ）

**特点**：

- 位移量是指令到目标地址的**相对偏移**，汇编时计算
- 短转移（SHORT）：位移量 8 位，范围 `-128 ~ +127`；
- 近转移（NEAR PTR）：位移量 16 位，范围 `-32768 ~ +32767`

示例：

```assembly
JMP SHORT NEXT  ; 短转移，IP += 8位位移
JMP NEAR PTR NEXT ; 近转移，IP += 16位位移
NEXT: ret       ; 目标地址
```

#### （2）段内间接寻址

**原理**：转向有效地址**存于寄存器或内存单元**，通过数据寻址方式（除立即数外）获取

示例：

- 寄存器间接：`JMP BX` → IP = BX 的值（如 BX=1256H，则 IP=1256H ）

- 内存间接（结合数据寻址）：

  ```assembly
  ; 假设 TABLE=20A2H, DS=2000H, BX=1256H，内存232F8H（2000H+20A2H+1256H）存3280H
  JMP WORD PTR TABLE[BX]  ; IP = (232F8H) = 3280H
  ; 或基址变址：BX=1256H, SI=528EH，内存264E4H（2000H+1256H+528EH）存2450H
  JMP WORD PTR [BX][SI]   ; IP = (264E4H) = 2450H
  ```

#### （3）段间直接寻址

**原理**：指令直接提供 **新的段地址（改 CS）和偏移地址（改 IP）**，实现跨段跳转

示例：

```assembly
; code1段跳转到code2段的next标签
code1 segment
    ...
    JMP FAR PTR next  ; CS = code2的段地址，IP = next的偏移地址
    ...
code1 ends

code2 segment
next: ...
code2 ends
```

#### （4）段间间接寻址

**原理**：从**内存连续两个字**中获取目标地址：低字→IP，高字→CS（需用`DWORD PTR`指定双字访问 ）

**约束**：内存地址需通过**非立即数、非寄存器**的数据寻址方式获取（如基址 + 变址 ）

示例：

```assembly
; INTERS是位移量，BX是变址，内存中连续双字：低字→IP，高字→CS
JMP DWORD PTR [INTERS + BX]
```

## 3.2、指令系统

### 一、数据传送指令

#### 1.通用数据传送指令

##### **（1）MOV 指令（数据传送）**

**格式**：`MOV DST, SRC`

**操作逻辑**：将源操作数 `SRC` 的内容复制到目的操作数 `DST`，即 `(DST) ← (SRC)`

**核心限制**：

- `DST` 不能是**CS（代码段寄存器）**（修改 CS 会直接改变程序执行流，风险高）；
- `DST` 和 `SRC` 不能**同时为段寄存器**（如 `MOV DS, ES` 非法）；
- **立即数不能直接写入段寄存器**（如 `MOV DS, 2000H` 非法，需通过通用寄存器中转，如 `MOV AX, 2000H` → `MOV DS, AX`）；
- `DST` 不能是**立即数**（目的必须是寄存器或内存单元）；
- `DST` 和 `SRC` 不能**同时为存储器寻址**（无法直接在两个内存单元间传送，需借助寄存器）

##### **堆栈基础**：

- 属于**堆栈段（SS）**的“**先进后出**”存储区，**SP 始终指向栈顶**（低地址端）；
- 操作单位为**字（2字节）**，高字节存高地址，低字节存低地址

##### **（2）PUSH 进栈指令**

**格式**：`PUSH SRC`

**执行步骤**：

1. **调整栈顶**：`SP ← SP - 2`（SP 向低地址移动，预留存储空间）；
2. **数据入栈**：将 `SRC` 的内容存入新栈顶（高字节写 `SP+1`，低字节写 `SP`），即 `((SP)+1, SP) ← SRC`

**限制**：

- 不能用**立即寻址**（如 `PUSH 1234H` 非法，需先存入寄存器）；
- 不影响标志位；
- `SRC` 可为通用寄存器、段寄存器（除 CS 外，因 `POP CS` 非法，故 `PUSH CS` 也需谨慎）

示例：若 `AX = 2107H`，执行 `PUSH AX`：

- SP 先减 2，然后 `21H`（高字节）存入 `SP+1`，`07H`（低字节）存入 `SP`，栈顶指向新 SP 位置

##### **（3）POP 出栈指令**

**格式**：`POP DST`

执行步骤：

1. **数据出栈**：将栈顶内容（`SP+1` 存高字节，`SP` 存低字节）传送到 `DST`，即 `DST ← ((SP)+1, SP)`；
2. **调整栈顶**：`SP ← SP + 2`（SP 向高地址移动，释放栈空间）

**限制**：

- `DST` 不能是**CS**（修改 CS 会破坏程序执行流程，如 `POP CS` 非法）；
- 不影响标志位

**示例**：执行 `POP BX` 时，栈顶的 `2107H`（`SP+1=21H`，`SP=07H`）被传送到 BX，随后 SP 加 2

##### **（4）XCHG 交换指令**

**格式**：`XCHG OPR1, OPR2`

**操作逻辑**：两个操作数内容互换，即 `OPR1 ↔ OPR2`

**限制**：

- 不影响标志位；
- **不能使用段寄存器**（操作数只能是通用寄存器或内存单元）

示例：

- `XCHG BX, [BP+SI]`：寄存器 BX 与内存单元（BP+SI 寻址）交换数据；
- `XCHG AL, BH`：寄存器 AL 和 BH 交换内容

##### **应用场景补充**

- PUSH/POP常用于保护/恢复现场（如子程序调用时保存寄存器值，返回前恢复）：

  ```assembly
  PUSH AX    ; 保存AX
  PUSH BX    ; 保存BX
  ...        ; 子程序逻辑（使用AX、BX）
  POP BX     ; 恢复BX
  POP AX     ; 恢复AX
  ```

- **XCHG** 可快速交换数据，避免额外寄存器暂存，提升代码效率

#### 2.累加器专用传送指令（仅限AX/AL参与）

##### **（1）IN 指令（I/O → CPU，输入数据）**

**功能**：从外部设备的I/O端口读取数据，存入**AL（字节）**或**AX（字）**

**格式与操作**

- **长格式**（端口号 ≤ 255，直接指定）：
  - 字节：`IN AL, PORT` → `(AL) ← (PORT)`（PORT为00H~FFH）；
  - 字：`IN AX, PORT` → `(AX) ← ((PORT+1), PORT)`（低地址PORT存AX低字节，高地址PORT+1存AX高字节）
- **短格式**（端口号 ≥ 256，通过DX间接指定）：
  - 字节：`IN AL, DX` → `(AL) ← ((DX))`（DX存端口号，读取该端口数据到AL）；
  - 字：`IN AX, DX` → `(AX) ← ((DX)+1, (DX))`（读取DX端口（低字节）和DX+1端口（高字节）到 AX）

##### **（2）OUT 指令（CPU → I/O，输出数据）**

**功能**：将**AL（字节）** 或**AX（字）**的数据写入外部设备的I/O端口

**格式与操作**

- **长格式**（端口号 ≤ 255，直接指定）：
  - 字节：`OUT PORT, AL` → `(PORT) ← (AL)`；
  - 字：`OUT PORT, AX` → `((PORT+1), PORT) ← (AX)`（AX低字节写PORT，高字节写PORT+1）
- **短格式**（端口号 ≥ 256，通过DX间接指定）：
  - 字节：`OUT DX, AL` → `((DX)) ← (AL)`（DX存端口号，AL数据写入该端口）；
  - 字：`OUT DX, AX` → `((DX)+1, (DX)) ← (AX)`（AX低字节写DX端口，高字节写DX+1端口）

##### **（3）XLAT 指令（换码，字节表格转换）**

**功能**：根据**BX（表格首地址）** 和**AL（偏移量）**，从字节表格中读取对应数据，更新AL

**格式与操作**

- **格式**：`XLAT` 或 `XLAT OPR`（OPR为表格符号，可省略，核心依赖BX和AL）
- **操作**：`(AL) ← ((BX) + (AL))`（BX指向表格首地址，AL存偏移量，相加后取内存值到 AL）

**使用条件**

- 表格为**字节型**，长度 ≤ 256（AL是 8 位，偏移量范围 0~255）；
- 需提前设置：`BX ← 表格首地址`，`AL ← 偏移量`

**示例**（假设 `DS=F000H`，表格 `TABLE` 首地址 `0040H`）：

```assembly
MOV BX, OFFSET TABLE   ; BX = F000:0040H（表格首地址）
MOV AL, 3              ; AL = 3（偏移量，指向 TABLE+3 位置）
XLAT                   ; AL ← (F000:0043H) = 33H（表格中该位置值为 33H）
```

##### **通用注意事项**

1. **标志位**：IN、OUT、XLAT均**不影响标志位**
2. **端口号范围**：
   - 长格式仅支持**00H~FFH**（256 个端口）；
   - 短格式通过**DX间接指定**，支持0000H~FFFFH（65536个端口）
3. **XLAT限制**：仅处理**字节表格**，且必须预先配置BX（首地址）和AL（偏移量）

#### 3.地址传送指令

##### **（1）LEA（Load Effective Address，有效地址送寄存器）**

**格式**：`LEA REG, SRC`

**操作**：计算 `SRC` 的**有效偏移地址**（而非数据），存入 `REG`

**关键对比（与 `MOV` 区别）**：

- `MOV BX, TABLE`：取 `TABLE` 对应内存**数据**（如 `TABLE` 处存 `0040H`，则 `BX=0040H`）；
- `LEA BX, TABLE`：取 `TABLE` 的**偏移地址**（如 `TABLE` 偏移为 `1000H`，则 `BX=1000H`）

示例：

```assembly
LEA BX, [BX+SI+0F62H]  ; 计算表达式 BX+SI+0F62H 的偏移地址，存入 BX
```

##### **（2）LDS（Load Pointer into Register and DS）**

**格式**：`LDS REG, SRC`

**操作（处理 4 字节双字指针）**：

1. 从 `SRC` 指向的内存取**低 2 字节**（偏移量），存入 `REG`；
2. 从 `SRC+2` 指向的内存取**高 2 字节**（段地址），存入**DS**

示例（结合内存布局，`DS=1000H`，`TABLE` 偏移 `1000H` 处存 `0040H` ，`1002H` 处存 `3000H`）：

```assembly
LDS BX, TABLE  ; BX ← 0040H（偏移），DS ← 3000H（段地址）
```

##### **（3）LES（Load Pointer into Register and ES）**

**格式**：`LES REG, SRC`

**操作（同LDS，仅段寄存器不同）**：

1. 从 `SRC` 取**低 2 字节**→`REG`（偏移）；
2. 从 `SRC+2` 取**高 2 字节**→**ES**（段地址）

示例（同内存布局，`SRC+2` 处存 `3000H`）：

```assembly
LES BX, TABLE  ; BX ← 0040H，ES ← 3000H
```

##### 通用规则与限制

1. **标志位**：LEA、LDS、LES均**不影响标志位**
2. **操作数约束**：
   - `REG` 必须是**通用寄存器**（AX、BX、SI、DI 等），**不能是段寄存器**（CS、DS等）；
   - `SRC` 必须是**存储器寻址**（如直接寻址、变址寻址），不能是寄存器或立即数
3. **数据结构**：LDS / LES 处理**连续 4 字节**（双字），低字存偏移，高字存段地址（对应 DS / ES）

#### 4.标志寄存器传送指令

##### **（1）LAHF（Load AH from Flags）：标志低字节 → AH**

**功能**：将**标志寄存器（PSW）的低 8 位**（包含 SF、ZF、AF、PF、CF）传送到AH

**操作**：`(AH) ← (PSW 的低字节)`

**特点**：

- 仅读取标志，**不修改标志寄存器本身**（标志位保持不变）；
- 常用于临时保存部分标志（低 8 位）

##### **（2）SAHF（Store AH to Flags）：AH → 标志低字节**

**功能**：将**AH的内容** 写入**PSW的低 8 位**，直接修改SF、ZF、AF、PF、CF标志

**操作**：`(PSW 的低字节) ← (AH)`

**特点**：

- **修改标志位**（低 8 位标志被AH的值覆盖）；
- 需提前通过AH预设标志状态，谨慎使用（可能破坏原有标志）

##### **（3）PUSHF（Push Flags）：标志寄存器 → 堆栈**

**功能**：将**整个标志寄存器（16 位）**压入堆栈，保存完整标志状态

**操作步骤**：

1. 调整栈顶：`SP ← SP - 2`（SP 向低地址移动，预留 2 字节空间）；
2. 标志入栈：`((SP)+1, SP) ← (PSW)`（高字节存 SP+1，低字节存 SP）

**特点**：

- 仅**保存标志到栈**，**不修改标志寄存器本身**（标志位不变，只改变 SP）；
- 常用于子程序调用前保存完整标志状态

##### **（4）POPF（Pop Flags）：堆栈 → 标志寄存器**

**功能**：将**堆栈顶的 16 位数据**弹出到标志寄存器，恢复标志状态

**操作步骤**：

1. 标志恢复：`PSW ← ((SP)+1, SP)`（从栈顶读取 16 位，覆盖标志寄存器）；
2. 调整栈顶：`SP ← SP + 2`（SP向高地址移动，释放栈空间）

**特点**：

- **直接修改整个标志寄存器**，**所有标志位被栈中值覆盖**（严重影响程序状态，需确保栈数据合法）；
- 与PUSHF配对，用于恢复之前保存的标志

##### **关键对比：对标志位的影响**

| 指令  | 是否修改标志寄存器？     | 影响范围                   |
| ----- | ------------------------ | -------------------------- |
| LAHF  | 否（仅读，不写）         | 无                         |
| SAHF  | 是（写低 8 位标志）      | SF、ZF、AF、PF、CF         |
| PUSHF | 否（仅保存到栈，不写回） | 无（只改 SP）              |
| POPF  | 是（写整个标志寄存器）   | 所有标志位（含 IF、TF 等） |

#### 5.类型转换指令

##### **核心逻辑：符号扩展**

针对**有符号数**，根据其**最高位（符号位）**扩展高位：

- 若为 **0（正数）**：高位补 0；

- 若为 **1（负数）**：高位补 1；

  目的是保持数值的**符号和大小**，为多字节运算（如除法）做准备

##### **（1）CBW（Convert Byte to Word）：字节 → 字扩展**

| 指令 | 功能                         | 操作对象 | 符号位位置  | 扩展规则                                                   |
| ---- | ---------------------------- | -------- | ----------- | ---------------------------------------------------------- |
| CBW  | 8 位有符号数 → 16 位有符号数 | AL → AX  | AL的第 7 位 | 正数（第 7 位 = 0）→ AH=00H； 负数（第 7 位 = 1）→ AH=0FFH |

**示例分析**

假设 `AX = 0BA45H`（即 `AL = 45H`，二进制 `0100 0101`，第 7 位为 **0**，表示正数）：

```assembly
CBW   ; 步骤：  
      ; 1. 检测AL最高位：0 → 正数；  
      ; 2. AH填充00H → AX = 0045H（保持正数，数值不变）  
```

##### **（2）CWD（Convert Word to Doubleword）：字 → 双字扩展**

| 指令 | 功能                          | 操作对象   | 符号位位置    | 扩展规则                                                     |
| ---- | ----------------------------- | ---------- | ------------- | ------------------------------------------------------------ |
| CWD  | 16 位有符号数 → 32 位有符号数 | AX → DX:AX | AX 的第 15 位 | 正数（第 15 位 = 0）→ DX=0000H； 负数（第 15 位 = 1）→ DX=0FFFFH |

**示例分析**

假设 `AX = 0BA45H`（二进制 `1011 1010 0100 0101`，第 15 位为 **1**，表示负数）：

```assembly
CWD   ; 步骤：  
      ; 1. 检测AX最高位：1 → 负数；  
      ; 2. DX填充0FFFFH → DX:AX = 0FFFFH:0BA45H（保持负数，数值不变）  
```

##### **通用规则与注意**

1. **无操作数**：指令隐式操作 `AL`（CBW）或 `AX`（CWD），无需显式指定
2. **仅对有符号数有效**：若处理无符号数，扩展逻辑不适用（需用其他指令，如 `MOVZX`）
3. **标志位无关**：CBW、CWD**不修改条件标志位**，只改变寄存器内容

### 二、算数指令

#### 1.加法指令

##### **（1）指令分类与基本操作**

| 指令    | 格式           | 执行操作                     | 核心场景               |
| ------- | -------------- | ---------------------------- | ---------------------- |
| **ADD** | `ADD DST, SRC` | `(DST) ← (DST) + (SRC)`      | 普通加法（单精度）     |
| **ADC** | `ADC DST, SRC` | `(DST) ← (DST) + (SRC) + CF` | 多字节加法（双精度等） |
| **INC** | `INC OPR`      | `(OPR) ← (OPR) + 1`          | 自增（如循环计数）     |

##### **（2）条件标志位的影响规则**

加法指令修改**CF（进位）、OF（溢出）、ZF（零）、SF（符号）**，规则如下：

| 标志位 | 判定逻辑                                                     | 物理意义           |
| ------ | ------------------------------------------------------------ | ------------------ |
| **SF** | 结果最高位为 1 → SF=1（负数）；否则SF=0（正数）              | 结果的符号属性     |
| **ZF** | 结果为 0 → ZF=1；否则ZF=0                                    | 结果是否为零       |
| **CF** | 无符号数加法时，最高位有进位 → CF=1（表示 **无符号溢出**）；否则CF=0 | 无符号数的溢出判断 |
| **OF** | 带符号数加法时，**两个操作数符号相同，但结果符号相反** → OF=1（表示**带符号溢出**）；否则OF=0 | 带符号数的溢出判断 |

##### **（3）标志位的场景化示例（8 位运算）**

以 **8 位二进制**为例，分四种溢出场景（带符号：-128 ~ 127；无符号：0 ~ 255）：

| 场景           | 运算示例（二进制）                                      | 带符号结果 | OF   | 无符号结果      | CF   | 结论                     |
| -------------- | ------------------------------------------------------- | ---------- | ---- | --------------- | ---- | ------------------------ |
| **都不溢出**   | `0000 0100 (+4) + 0000 1011 (+11) = 0000 1111 (+15)`    | +15        | 0    | 15              | 0    | 无溢出                   |
| **都溢出**     | `1000 0111 (-121) + 1111 0101 (-11) = 0111 1100 (+124)` | +124       | 1    | 135+245=380→124 | 1    | 带符号和无符号均溢出     |
| **无符号溢出** | `0000 0111 (+7) + 1111 1011 (-5→251) = 0000 0010 (+2)`  | +2         | 0    | 7+251=258→2     | 1    | 无符号溢出，带符号未溢出 |
| **带符号溢出** | `0000 1001 (+9) + 0111 1100 (+124) = 1000 0101 (-123)`  | -123       | 1    | 9+124=133       | 0    | 带符号溢出，无符号未溢出 |

##### **（4）关键区别与注意**

1. **ADD vs ADC**：
   - ADC需配合CF使用，实现**多字节连续进位**（如双精度、四精度加法）；
   - ADD仅处理单精度加法，不考虑之前的进位
2. **INC 的特殊性**：
   - 只对**单个操作数**加 1，**不影响CF标志**（但会修改 ZF、SF、OF）；
   - 示例：`INC BX` 仅将BX加 1，CF保持原值
3. **标志位的解读逻辑**：
   - **CF** 对应**无符号数**的溢出（如计数溢出）；
   - **OF** 对应**带符号数**的溢出（如温度值超过范围）；
   - 需根据操作数的 “有符号 / 无符号” 属性，选择关注CF或OF

#### 2.减法指令

##### **（1）指令分类与核心操作**

| 指令    | 格式             | 执行操作                                          | 核心用途                       |
| ------- | ---------------- | ------------------------------------------------- | ------------------------------ |
| **SUB** | `SUB DST, SRC`   | `(DST) ← (DST) - (SRC)`                           | 单精度减法（无借位）           |
| **SBB** | `SBB DST, SRC`   | `(DST) ← (DST) - (SRC) - CF`                      | 多精度减法（处理低位借位）     |
| **DEC** | `DEC OPR`        | `(OPR) ← (OPR) - 1`                               | 自减（如循环计数）             |
| **NEG** | `NEG OPR`        | `(OPR) ← - (OPR)`（等价于 `0 - OPR`，即补码转换） | 求负数的补码（或取反加 1）     |
| **CMP** | `CMP OPR1, OPR2` | 计算 `OPR1 - OPR2`，**结果不保存**，仅修改标志位  | 判断两数大小关系（通过标志位） |

##### **（2）条件标志位的影响规则**

**SUB、SBB、CMP的标志逻辑**

- **CF（无符号溢出判断）**：
  - 无符号数减法中，若**被减数 < 减数**（如 `5 - 10`），被减数最高位向高位借位 → `CF=1`；否则 `CF=0`
  - 等价理解：减法转加法（`被减数 + (-减数)`）时，若加法**无进位**（即不够减），则 `CF=1`
- **OF（带符号溢出判断）**：
  - 带符号数减法中，若**被减数和减数符号相反，且结果符号与减数相同** → `OF=1`
  - 示例：
    - 正数减负数（如 `5 - (-3)`，本应得正），若结果为负 → 溢出（`OF=1`）；
    - 负数减正数（如 `-5 - 3`，本应得负），若结果为正 → 溢出（`OF=1`）
- **ZF、SF**：
  - `ZF=1` 当且仅当**结果为 0**（如 `SUB AX, AX` → `AX=0`，`ZF=1`）；
  - `SF=1` 当且仅当**结果最高位为 1**（表示负数）

**DEC的标志特殊性**

- **不影响 CF**：`DEC` 仅对操作数减 1，即使结果溢出（如 `0 - 1 = 0FFH`，无符号溢出），`CF` 仍保持原值；
- **影响 ZF、SF、OF**：若操作数为 1 → 减 1 后为 0（`ZF=1`）；若为 0 → 减 1 后为 - 1（`SF=1`）；若为 - 128（字节）→ 减 1 后溢出（`OF=1`）

**NEG 的标志规则（补码转换）**

- **CF**：
  - 若操作数**非 0**（如 `NEG AL`，AL≠0）→ `CF=1`（因为 `0 - OPR` 必然借位）；
  - 若操作数**为 0**（`NEG AX`，AX=0）→ `CF=0`（`0-0` 无借位）
- **OF**：
  - 仅当操作数为**字节的 - 128（80H）** 或**字的 - 32768（8000H）** 时，`OF=1`（因为它们的补码超出带符号数范围，如 `-128` 求补后还是 `-128`，导致溢出）；
  - 其他情况 `OF=0`

##### **（3）多精度运算示例（32 位减法配合）**

**需求**：计算 `w = x + y + 24 - z`，其中 `x、y、z` 是 **32 位双精度数**（低 16 位存 `X、Y、Z`，高 16 位存 `X+2、Y+2、Z+2`），结果存入 `W（低16位）` 和 `W+2（高16位）`

**指令序列与解析**：

```assembly
; 1. 加载 x 的低16位到 AX，高16位到 DX  
MOV AX, X        ; AX ← x低16位  
MOV DX, X+2      ; DX ← x高16位  

; 2. 加 y：低16位用 ADD，高16位用 ADC（处理低位进位）  
ADD AX, Y        ; AX ← x低16位 + y低16位（产生 CF）  
ADC DX, Y+2      ; DX ← x高16位 + y高16位 + CF（完成 x+y）  

; 3. 加 24：低16位直接加，高16位加 CF（24是8位，可能进位到高16位）  
ADD AX, 24       ; AX ← (x+y)低16位 + 24（产生 CF）  
ADC DX, 0        ; DX ← (x+y)高16位 + 0 + CF（完成 x+y+24）  

; 4. 减 z：低16位用 SUB，高16位用 SBB（处理低位借位）  
SUB AX, Z        ; AX ← (x+y+24)低16位 - z低16位（产生 CF）  
SBB DX, Z+2      ; DX ← (x+y+24)高16位 - z高16位 - CF（完成 x+y+24-z）  

; 5. 保存结果到 W（低16位）和 W+2（高16位）  
MOV W, AX        ; W ← 结果低16位  
MOV W+2, DX      ; W+2 ← 结果高16位  
```

**关键逻辑**：

- **ADD + ADC**处理**多精度加法**的进位；
- **SUB + SBB**处理**多精度减法**的借位（SBB自动减去低位的CF）；
- 加常数 24 时，高 16 位用 `ADC DX, 0` 捕获低位的进位（即使 24 是 8 位，也可能导致AX溢出到DX）

##### **（4）指令对比与应用场景**

| 指令 | 适用场景                       | 标志位特点                       | 易错点                    |
| ---- | ------------------------------ | -------------------------------- | ------------------------- |
| SUB  | 单精度无借位减法               | 影响 CF、OF、ZF、SF              | 无符号数需检查 CF         |
| SBB  | 多精度减法（如 64 位、128 位） | 依赖 CF，需与 SUB 配合           | 忘记提前处理 CF           |
| DEC  | 循环计数自减                   | 不影响 CF，需注意 ZF/SF/OF       | 误用 DEC 修改标志         |
| NEG  | 求补码（如负数转正数）         | CF=1（非 0 时），OF 仅极端值触发 | 处理 - 128/-32768 时的 OF |
| CMP  | 判断两数大小（如跳转前比较）   | 仅修改标志，不改变操作数         | 混淆 OPR1 和 OPR2 顺序    |

#### 3.乘法指令

**（1）指令架构：隐含寄存器与操作**

乘法指令依赖**隐含寄存器**实现运算，结果长度为操作数的 2 倍（字节→字，字→双字）：

| 指令     | 操作数宽度 | 乘数寄存器（隐含）         | 乘积寄存器（隐含）         | 执行操作                              |
| -------- | ---------- | -------------------------- | -------------------------- | ------------------------------------- |
| **MUL**  | 字节       | AL（被乘数） + SRC（乘数） | AX ← AL × SRC（无符号）    | 无符号数乘法，结果存AX                |
| **MUL**  | 字         | AX（被乘数） + SRC（乘数） | DX:AX ← AX × SRC（无符号） | 结果存双字（DX高 16 位，AX 低 16 位） |
| **IMUL** | 字节       | AL（被乘数） + SRC（乘数） | AX ← AL × SRC（带符号）    | 带符号数乘法（补码运算），结果存AX    |
| **IMUL** | 字         | AX（被乘数） + SRC（乘数） | DX:AX ← AX × SRC（带符号） | 结果存双字（DX高 16 位，AX低 16 位）  |

##### **（2）关键约束**

1. **操作数限制**：`SRC` 不能是**立即数**（需预先存入寄存器或内存单元）
2. **标志位规则**：仅**CF（进位 / 借位）、OF（溢出）**有定义，其余标志（ZF、SF、PF 等）**无定义**（结果随机，不可依赖）

##### **（3）CF/OF标志的判定逻辑**

| 指令               | CF/OF = 00 的条件                                            | CF/OF = 11 的条件                                |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------ |
| **MUL**（无符号）  | 乘积的**高半部分为 0**（如字节乘后AX 高 8 位为 0，字乘后DX为 0） | 高半部分**非 0**（结果超出低半范围，无符号溢出） |
| **IMUL**（带符号） | 乘积的**高半部分是低半部分的符号扩展**（如负数高半全 1，正数高半全 0） | 高半部分**非符号扩展**（带符号溢出）             |

##### **（4）示例拆解：理解标志位与运算**

**案例 1：字节带符号乘法（IMUL BL）**

初始值：`AX = 16A5H`（`AL = A5H`，带符号为 **-91**），`BX = 0611H`（`BL = 11H`，带符号为 **17**）

执行：`IMUL BL`（AL × BL，带符号运算）

- 计算：`-91 × 17 = -1547`，补码为**F9F5H**（存入 AX）
- 标志分析：AX 高 8 位 `F9H`（1111 1001）≠ 低 8 位 `F5H`（1111 0101）的符号扩展（符号扩展要求高 8 位全 1，即 `FFH`）→ **CF=1，OF=1**（带符号溢出）

**案例 2：字无符号乘法（MUL BX）**

初始值：`AX = 16A5H`（无符号：6821），`BX = 0611H`（无符号：1553）

执行：`MUL BX`（AX × BX，无符号运算）

- 计算：`6821 × 1553 = 10,593,013`，十六进制为 **0089 5EF5H**（DX=0089H，AX=5EF5H）
- 标志分析：DX（高 16 位）≠ 0 → **CF=1，OF=1**（无符号溢出）

##### **（5）核心差异与应用场景**

| 维度         | MUL（无符号）                      | IMUL（带符号）                             |
| ------------ | ---------------------------------- | ------------------------------------------ |
| **运算本质** | 二进制直接相乘（无符号规则）       | 补码相乘（保留符号，如负数 × 负数 = 正数） |
| **标志意义** | CF=1 表示无符号结果超出低半范围    | OF=1 表示带符号结果超出补码范围            |
| **典型场景** | 地址计算、无符号数据（如数组索引） | 带符号数值（如温度、海拔、偏移量）         |
| **易错点**   | 忽略高半部分非零导致溢出           | 误判符号扩展导致标志位错误                 |

####  4.除法指令

##### **（1）指令架构：隐含寄存器与运算逻辑**

除法指令通过**隐含寄存器**处理被除数、商和余数，结果长度为操作数的 2 倍（字节→字，字→双字）：

| 指令     | 操作数宽度 | 被除数（隐含） | 商（隐含）  | 余数（隐含） | 运算属性           |
| -------- | ---------- | -------------- | ----------- | ------------ | ------------------ |
| **DIV**  | 字节       | AX（16 位）    | AL（8 位）  | AH（8 位）   | 无符号除法         |
| **DIV**  | 字         | DX:AX（32 位） | AX（16 位） | DX（16 位）  | 无符号除法         |
| **IDIV** | 字节       | AX（16 位）    | AL（8 位）  | AH（8 位）   | 带符号除法（补码） |
| **IDIV** | 字         | DX:AX（32 位） | AX（16 位） | DX（16 位）  | 带符号除法（补码） |

##### **（2）关键约束与风险**

1. **操作数限制**：`SRC` 不能是**立即数**（需预先存入寄存器 / 内存）
2. **标志位**：所有条件标志（CF、OF、ZF、SF、PF 等）**无定义**（结果随机，不可依赖）
3. **溢出中断**：若商超出目标寄存器范围（如字节除法商 > 255，字除法商 > 65535），触发**除法溢出中断**（程序崩溃）

##### **（3）带符号运算的核心：符号扩展（如 CWD）**

**场景**：当 16 位带符号数（如 `z`、`v`）参与 32 位运算时，必须用**CWD**将其符号扩展为 32 位（`DX:AX`），确保负数的高位补 1（正数补 0）

示例：

- 若 `z = -1`（16 位补码 `FFFFH`），`CWD` 后 `DX=FFFFH`（符号扩展），32 位表示仍为 `-1`；
- 若未扩展，`DX=0000H`，会被当作 `65535`（无符号），导致运算错误

##### **（4）复杂运算示例拆解（带符号除法）**

**需求**：计算 `(v - (x*y + z - 540)) / x`，其中 `x、y、z、v` 是 16 位带符号数

**步骤与指令逻辑**：

1. **计算 `x*y`（带符号乘法，IMUL）**：

   ```assembly
   MOV AX, X      ; AX ← x（16位被乘数）
   IMUL Y         ; DX:AX ← x×y（32位带符号结果）
   MOV CX, AX     ; CX ← 低16位（暂存）
   MOV BX, DX     ; BX ← 高16位（暂存）
   ```

2. **计算 `x*y + z`（32 位加法，ADD+ADC）**：

   ```assembly
   MOV AX, Z      ; AX ← z（16位加数）
   CWD            ; DX:AX ← z的32位符号扩展（准备相加）
   ADD CX, AX     ; 低16位相加：(x*y低16位) + (z低16位)
   ADC BX, DX     ; 高16位相加：(x*y高16位) + (z高16位) + CF（进位）
   ```

3. **计算 `x*y + z - 540`（32 位减法，SUB+SBB）**：

   ```assembly
   SUB CX, 540    ; 低16位减540：(x*y+z低16位) - 540
   SBB BX, 0      ; 高16位减0 + 借位：(x*y+z高16位) - 0 - CF（借位）
   ```

4. **计算 `v - (x*y + z - 540)`（32 位减法，SUB+SBB）**：

   ```assembly
   MOV AX, V      ; AX ← v（16位被减数）
   CWD            ; DX:AX ← v的32位符号扩展（准备相减）
   SUB AX, CX     ; 低16位相减：(v低16位) - (x*y+z-540低16位)
   SBB DX, BX     ; 高16位相减：(v高16位) - (x*y+z-540高16位) - CF（借位）
   ```

5. **除以 `x`（带符号除法，IDIV）**：

   ```assembly
   IDIV X         ; 被除数：DX:AX（32位），除数：X（16位）
                  ; 商 → AX，余数 → DX（带符号，与被除数同号）
   ```

##### **（5）DIV 与 IDIV 的核心差异**

| 维度         | DIV（无符号）            | IDIV（带符号）                         |
| ------------ | ------------------------ | -------------------------------------- |
| **运算规则** | 二进制直接除（无符号）   | 补码运算（保留符号，余数同被除数符号） |
| **余数符号** | 永远为正（无符号）       | 与被除数符号一致（如被除数负，余数负） |
| **符号扩展** | 无需（无符号数高位补 0） | 必须（带符号数用 CWD/CDQ 扩展）        |
| **溢出判断** | 商超范围→中断            | 同 DIV，商超范围→中断                  |

#### 5.十进制调整指令

##### **（1）BCD 码基础**

**定义**：

- **BCD（Binary-Coded Decimal）**：用二进制编码表示十进制数，每 1 位十进制对应**4 位二进制（8421 码）**，确保每 4 位仅表示 `0~9`（避免 10~15 的无效编码）

**两种编码形式**：

| **类型**       | 存储方式                                                     | 示例（59₁₀）                                                 | 应用场景                 |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------ |
| **压缩 BCD**   | 1 字节存 2 位十进制（4 位 / 位）                             | `0101 1001B`（5 和 9 各占 4 位）                             | 紧凑存储（如财务数据）   |
| **非压缩 BCD** | 1 字节存 1 位十进制（低 4 位有效，高 4 位可为 0 或ASCII 前缀） | - 纯 BCD：`0000 0101B`（5） + `0000 1001B`（9）； - ASCII 码：`0011 0101B`（'5'，高 4 位固定`0011`） | 输入输出（如键盘、显示） |

#### **（2）BCD 运算的核心问题：二进制加法偏差**

**场景**：压缩BCD的 `19（0001 1001） + 8（0000 1000）`

**二进制运算结果**：`0001 1001 + 0000 1000 = 0001 0001`（二进制值 17，错误）

**实际BCD结果**：应得 `27（0010 0111）`

**偏差原因**：二进制加法未识别BCD的 “每 4 位≤9” 规则，需**调整指令修正**（如加 6，利用`AF=1`标志）

##### **（3）十进制调整指令分类与逻辑**

针对**加法、减法、乘法、除法**的BCD运算，提供专用调整指令，核心依据**AF（半进位，4 位边界）、CF（全进位，8 位边界）**标志：

| **指令** | 功能                | 适用BCD类型 | 运算阶段            | 调整逻辑（简化）                                             |
| -------- | ------------------- | ----------- | ------------------- | ------------------------------------------------------------ |
| **DAA**  | 压缩BCD加法后调整   | 压缩 BCD    | 加法后（ADD / ADC） | - 若`AF=1`或低 4 位 > 9 → 加 6（修正低 4 位）； - 若`CF=1`或高 4 位 > 9 → 加 60H（修正高 4 位） |
| **DAS**  | 压缩BCD减法后调整   | 压缩 BCD    | 减法后（SUB / SBB） | - 若`AF=1`或低 4 位 < 0 → 减 6（修正低 4 位）； - 若`CF=1`或高 4 位 < 0 → 减 60H（修正高 4 位） |
| **AAA**  | 非压缩BCD加法后调整 | 非压缩 BCD  | 加法后（ADD / ADC） | - 低 4 位 > 9 或`AF=1` → 加 6，置`AF=1`、`CF=1`； - 高 4 位清 0（保留低 4 位有效） |
| **AAS**  | 非压缩BCD减法后调整 | 非压缩 BCD  | 减法后（SUB / SBB） | - 低 4 位 < 0 或`AF=1` → 减 6，置`AF=1`、`CF=1`； - 高 4 位清 0（保留低 4 位有效） |
| **AAM**  | 非压缩BCD乘法后调整 | 非压缩 BCD  | 乘法后（MUL）       | - 将 AX 中二进制商转换为非压缩 BCD：`AX = AX ÷ 10`，商存 AL，余数存 AH |
| **AAD**  | 非压缩BCD除法前调整 | 非压缩 BCD  | 除法前（DIV）       | - 将 AX 中非压缩BCD转换为二进制：`AX = AH×10 + AL`，AH 清 0（准备除法） |

##### **（4）BCD存储示例：3590₁₀的压缩与非压缩表示**

- **压缩BCD（1 字节存 2 位，共 2 字节，小端序：低位在前）**：
  - 编码：`0011 0101 1001 0000B`（3、5、9、0 各占 4 位）
  - 存储到数据区 `PAKED`：
    - 低字节（十位 + 个位）：`90H`（9 和 0）；
    - 高字节（千位 + 百位）：`35H`（3 和 5）；
    - 内存布局：`PAKED: DB 90H, 35H`
- **非压缩BCD（1 字节存 1 位，共 4 字节，小端序：个位在前）**：
  - 编码：`00000011B`（3，千位）、`00000101B`（5，百位）、`00001001B`（9，十位）、`00000000B`（0，个位）
  - 存储到数据区 `UNPAK`：
    - 地址 0（个位）：`00H`（0）；
    - 地址 1（十位）：`09H`（9）；
    - 地址 2（百位）：`05H`（5）；
    - 地址 3（千位）：`03H`（3）；
    - 内存布局：`UNPAK: DB 00H, 09H, 05H, 03H`
