# 第五章 **自底向上语法分析**

## **自底向上解析**

### **$LR(1) $解析**

**名称含义**：

`L`：输入从左向右扫描

`R`：生成最右推导

`1`：使用 **1 个符号的前瞻**

### **$LR(0) $解析**

**特点**：**无需前瞻符号**即可做出解析决策

**原理**：前瞻符号出现在解析栈后才会被检查，因此不算作“前瞻”

### **$SLR(1) $解析（简单$ LR $解析）**

**改进点**：在$ LR(0) $基础上**引入部分前瞻**

**能力**：比$ LR(0) $更强，但弱于$ LR(1)$

### **$LALR(1) $解析（前瞻$ LR $解析）**

**能力**：比$ SLR(1) $更强，但比 $LR(1) $稍弱

## 5.1 自底向上概述

### 一、**自底向上解析（移进-归约解析）核心机制**

1. **解析器结构**：
   
   - **解析栈**：位于左侧，存储已处理的符号
   - **输入**：位于中心，待解析的字符串（以 `$` 结尾表示终止符）
   - **动作**：位于右侧，包括 `shift`、`reduce` 和 `accept`
   
2. **两个核心动作**：
   
   - **移进**：将输入的首个终结符移到栈顶
   - **归约**：将栈顶的符号串 `α` 归约为非终结符 `A`（需匹配文法规则 `A → α`）
   
3. **文法增广**：
   
   新增起始符号 `S'` 和产生式：  **`S' → S`**  （`S` 为原文法起始符号，确保最终归约目标唯一）

**示例解析：输入字符串 `()`**

使用增广文法：  
```
S' → S 
S → (S)S | ε  
```

**解析过程**

| 步骤 | 解析栈  | 剩余输入 | 动作               |
| ---- | ------- | -------- | ------------------ |
| 1    | `$`     | `()$`    | 移进 `(`           |
| 2    | `$(`    | `)$`     | 归约 `S → ε`       |
| 3    | `$(S`   | `)$`     | 移进 `)`           |
| 4    | `$(S)`  | `$`      | 归约 `S → ε`       |
| 5    | `$(S)S` | `$`      | 归约 `S → (S)S`    |
| 6    | `$S`    | `$`      | 归约 `S' → S`      |
| 7    | `$S'`   | `$`      | **接受（accept）** |

**关键步骤解析**

**步骤 1-2**：  移进 `(` 后，栈顶无完整规则，将空串 `ε` 归约为 `S`（隐式匹配 `S → ε`）

**步骤 3-4**：  移进 `)` 后，再次归约空串为 `S`，形成栈 `$(S)S`

**步骤 5-6**：  将栈顶 `(S)S` 归约为 `S`（匹配 `S → (S)S`），再归约 `S` 为 `S'`

**步骤 7**：  栈顶为 `S'` 且输入结束，解析成功

> **注**：归约 `S → ε` 实质是向栈中隐式插入空符号，为后续规则匹配提供上下文

### 二、**核心概念解析**

1. **移进-归约解析与最右推导**  
   
   移进-归约解析过程实质是**最右推导的逆序**（反向构建语法树）
   
   例如：  `S' → S → (S)S → (S) → ()`  
   
   解析时归约顺序为：`() → (S) → (S)S → S → S'`
   
2. **右句型**  
   
   **定义**：最右推导过程中产生的每个中间符号串（含终结符与非终结符）  
   
3. **可行前缀**  
   
   **定义**：右句型在 **`$` 分隔符右侧**的部分（解析栈内容），且该前缀**不超过句柄末端**
   
   **关键特性**：  
   
   - 必须是右句型的**合法前缀**，能继续解析而不导致错误
   - 解析栈始终存储某个右句型的可行前缀  
   
   **示例**：  
   
   | 步骤 | 解析栈 | 剩余输入 | 可行前缀          |
   | ---- | ------ | -------- | ----------------- |
   | 3    | `$E`   | `+n$`    | `E`               |
   | 4    | `$E+`  | `n$`     | `E+`              |
   | 5    | `$E+n` | `$`      | `E+n`（完整句柄） |
   *非可行前缀*：`n+` 不是 `n+n` 的可行前缀（因解析栈从未出现此组合）
   
4. **句柄（Handle）**  
   
   **定义**：右句型中**可归约的子串**及其对应的产生式规则
   
   - 包含三要素：**子串内容**、**在右句型中的位置**、**归约用的产生式**
   
   **核心作用**：指示下一步归约操作
   
   **示例**：  
   
   - 右句型 `n + n` 的句柄是 **`n`**（子串） + **`E → n`**（产生式）→ 归约后得新右句型 `E + n`
   - 右句型 `E + n` 的句柄是 **`E + n`**（子串） + **`E → E + n`**（产生式）→ 归约后得 `E`

**解析栈动态**：  

`$` → `$n`（移进）→ `$E`（归约）→ `$E+`（移进）→ `$E+n`（移进）→ `$E`（归约）→ `$E'`（接受）  

**可行前缀演变**：`n` → `E` → `E+` → `E+n`（始终是右句型的前缀）

**关键结论**

1. 移进-归约解析通过不断识别**句柄**推进，直至归约为起始符号 
2. **可行前缀**是解析栈内容的抽象表示，其边界由句柄位置决定  
3. 句柄必须同时满足：  
   - **完整匹配**某产生式右部  
   - 位于栈顶（即**可行前缀末端**）  
4. 自底向上解析的实质是： **反向最右推导 + 可行前缀扩展 + 句柄归约**的循环过程

### 三、**移进-归约解析中的句柄判定与关键问题**

#### **1. 句柄的核心定义**

**句柄**是右句型中**可归约的子串**，必须满足：  

1. **完整匹配**某个产生式的右部
2. **归约后**得到的符号串仍是合法的右句型（即属于文法的最右推导过程）
3. 句柄的**最右符号**必须位于解析栈的栈顶，才能触发归约

#### **2. 句柄判定的关键条件**

**候选产生式匹配**：  

当栈顶符号串**完全匹配**某产生式右部时，该产生式成为归约候选

**但需验证归约后的合法性**：归约结果必须是右句型，否则无效

#### **3. ε-产生式的特殊处理**

**问题**：ε-产生式（如 `S → ε`）的右部为空串，理论上**任何时刻**栈顶都“匹配”空串

**解决**：仅当归约后能生成合法右句型时，才允许归约

#### 4. 移进-归约冲突的避免

**核心原则**：仅当**栈顶符号串是唯一合法句柄**时才归约，否则移进

**依赖技术**：  

- **$LR(0)/SLR(1) $自动机**：通过状态转移确定当前可行前缀是否对应句柄
- **$Follow $集$(SLR(1))$**：检查前瞻符号是否允许归约

## 5.2 $LR (0)$项的有限自动机

### 一、$LR (0)$项目

#### **1. 定义**

$LR (0)$项目是**上下文无关文法产生式**的一种扩展形式，通过在产生式右部标记一个**区分位置（用圆点・表示）**，记录语法分析的**中间状态**

形式化描述：

若文法的产生式为$A→α$（$A$是非终结符，$α$是右部符号串），且$α$可分解为$βγ$（$β$、$γ$是符号串，包括空串 $ε$），则$A→β⋅γ$称为**$LR (0)$项目**

- 圆点左侧的$β$表示**已识别的符号串**，右侧的 $β$ 表示**待识别的符号串**
- $LR (0)$的 “0” 表示**不依赖前瞻符号**，仅通过当前状态判断归约 / 移进

#### **2. 示例：文法与 $LR (0)$ 项目**

以示例文法为例：

```S' → S  
S' →$s$ 
S → (S)S | ε  
```

##### （1）产生式分析

该文法包含 **3 条产生式**：

`S' → S`（右部长度为 1，符号为 `S`）

`S → (S)S`（右部长度为 4，符号为 `(`, `S`, `)`, `S`）

`S → ε`（右部长度为 0，空串）

##### （2）生成$ $LR (0)$ $项目

根据 “右部长度决定圆点位置数（长度为$n$的右部有$n+1$个圆点位置）”，逐一生成项目：

| 产生式     | 右部长度 | 圆点位置（共*n*+1 个）              | 对应的 $LR (0)$ 项目                                         |
| ---------- | -------- | ----------------------------------- | ------------------------------------------------------------ |
| `S' → S`   | 1        | 0（圆点在最前）、1（圆点在最后）    | `S' → ·S`；`S' → S·`                                         |
| `S → (S)S` | 4        | 0,1,2,3,4（圆点依次后移）           | `S → ·(S)S`；`S → (·S)S`；`S → (S·)S`；`S → (S)·S`；`S → (S)S·` |
| `S → ε`    | 0        | 仅 0 位置（圆点在最前，因右部为空） | `S → ·`                                                      |

最终，该文法共生成 **8 个$ $LR (0)$ $项目**，与示例一致：
`S' → ·S`, `S' → S·`, `S → ·(S)S`, `S → (·S)S`, `S → (S·)S`, `S → (S)·S`, `S → (S)S·`, `S → ·`

#### **3. 项目的意义**

$LR (0)$项目通过**圆点位置**记录**产生式右部的识别进度**：

**初始项**（如 `A → ·α`）：即将开始用产生式 `A → α` 识别非终结符 `A`（圆点在最前，未匹配任何符号）

**中间项**（如 `A → β·γ`）：已匹配 `β`，待匹配 `γ`（记录分析的中间步骤）

**完整项**（如 `A → α·`）：`α` 已完全匹配，若后续归约，`α` 可能是**句柄**（可归约为 `A`）

### 二、项目的有限自动机

#### 1. 核心定位

$LR (0)$项目可作为**有限自动机的状态**，用于跟踪**语法分析栈的状态**和**移进 - 归约的执行进度**

该自动机最初是**非确定有限自动机（$$NFA$$）**，可通过 “子集构造法”转换为确定有限自动机（$DFA$），也可直接构造$ DFA$

#### 2. $NFA$的转移规则

$NFA$的状态是$LR (0)$项目，转移由**项目中圆点右侧的符号$X$** 驱动，分两类逻辑：

##### （1）基础转移（对任意符号$ X$）

若项目为$A \to \alpha \boldsymbol{\cdot} X\eta$（圆点后紧跟符号$X$，$\eta$为剩余符号串），则存在**符号$ X $上的转移**： 

从状态$A \to \alpha \boldsymbol{\cdot} X\eta$ 转移到$A \to \alpha X \boldsymbol{\cdot} \eta$，表示 “已匹配$\alpha X$，待匹配$\eta$”

图形化表示：
$$
\overset{A \to \alpha \cdot X\eta}{\circ} \quad \xrightarrow{X} \quad \overset{A \to \alpha X \cdot \eta}{\circ}
$$

##### （2）按$ X $的类型细化解释

- **当$X $是终结符（Token）**： 转移对应**移进操作**：将输入中的$X$移至分析栈顶，匹配项目中圆点后的$X$

- **当$X $是非终结符**：$X$不会直接出现在输入中，需通过**归约**生成（即先识别$X$的产生式右部$\beta$，再归约为 $X$）

  此时：对$X$的每个产生式$X \to \beta$，为项目$A \to \alpha \boldsymbol{\cdot} X\eta$ 添加**ε-转移**，指向$X$的**初始项**$X \to \boldsymbol{\cdot} \beta$（标记 “即将开始识别$\beta$，生成$X$”）

  图形化整合（基础转移 + ε-转移）：
  $$
  \begin{cases} 
  \overset{A \to \alpha \cdot X\eta}{\circ} \quad \xrightarrow{\varepsilon} \quad \overset{X \to \cdot \beta}{\circ} \quad \text{（为 } X \text{ 的每个产生式 } X \to \beta \text{ 添加）} \\
  \overset{A \to \alpha \cdot X\eta}{\circ} \quad \xrightarrow{X} \quad \overset{A \to \alpha X \cdot \eta}{\circ} \quad \text{（基础转移）} \\
  \end{cases}
  $$

#### 3. $NFA$ 的初始状态与文法增广

**初始状态的冲突**： 原文法的开始符$S$可能有多个产生式（如$S \to \alpha_1 \mid \alpha_2 \mid \dots$），每个对应初始项$S \to \boldsymbol{\cdot} \alpha_i$，无法确定唯一初始状态

**解决：增广文法**： 添加**新开始符$S'$**和产生式$S' \to S$（增广产生式），使文法唯一化

此时：$NFA$的**初始状态**为增广产生式的初始项$S' \to \boldsymbol{\cdot} S$（表示 “即将开始识别原文法的$S$”）

#### 4. 关键结论

$LR (0)$项目的$NFA$通过**状态（项目）** 和**转移（符号 /ε 驱动）**模拟移进 - 归约过程：

- 终结符转移对应 “移进”，非终结符转移关联 “归约前的识别流程”（通过 ε 转移连接初始项）
- 增广文法解决了初始状态的唯一性问题，为自动机构建提供统一入口

#### 5.求法

1. 为每一个非完整项添加基础转移
2. 若项目圆点后是非终结符，则添加ε-转移指向该非终结符的所有初始项

### 三、状态 - 栈驱动的移进 - 归约机制

#### 1. 分析栈的设计

$LR (0)$分析依赖**项目集$ DFA $的当前状态**，因此需扩展分析栈：

栈中同时存储**文法符号**和**状态编号**（每次压入符号后，紧跟压入新状态号）

示例栈结构（`$`为栈底标记，`0`是初始状态）：
$$
\begin{array}{|c|c|} \hline \text{分析栈（Parsing stack）} & \text{输入（input）} \\ \hline \$0 & \text{Input String} \\ \hline \$0\ \text{n}\ 2 & \text{Rest input string} \\ \hline \end{array}
$$

#### 2. 移进操作

**条件**：若当前状态$s$包含项目$A \to \alpha \boldsymbol{\cdot} X\beta$（$X$是终结符）

 **动作**：

1. 将输入的当前终结符$X$压入栈；
2. 找到状态$s$中项目$A \to \alpha \boldsymbol{\cdot} X\beta$ 转移后的状态（即$A \to \alpha X \boldsymbol{\cdot} \beta$ 所在的状态），将该状态号压入栈；
3. 若输入符号不是$X$（对状态$s$中所有此类项目），则报错

#### 3. 归约操作

**条件**：若当前状态$s$包含**完整项目**（形式为$A \to \gamma \boldsymbol{\cdot}$，即右部完全匹配）

**动作**：

1. **接受（特殊归约）**：若归约规则是增广产生式$S' \to S$（$S$是原文法开始符），且输入为空，则分析成功；若输入非空，报错
2. 普通归约：
   - 从栈顶弹出**符号串$\gamma$**及其对应的所有状态（因 DFA 构造，$\gamma$必在栈顶）；
   - 回退到$DFA$中开始构造$\gamma$的状态（弹出$\gamma$后暴露的状态，记为$s'$）；
   - 状态$s'$中必存在项目$B \to \alpha \boldsymbol{\cdot} A\beta$（$A$是归约后的非终结符）；
   - 将$A$压入栈，再将$B \to \alpha A \boldsymbol{\cdot} \beta$所在的状态号压入栈（对应 DFA 中$A$上的转移）

#### 4. 示例解析

**文法$A' \to A \mid A \to (A) \mid A \to a$**

以输入`((a))$`为例，结合 DFA 状态（左图）和分析过程（下表）：

| 步骤 | 分析栈               | 输入     | 动作                | 解释                                                         |
| ---- | -------------------- | -------- | ------------------- | ------------------------------------------------------------ |
| 1    | `$0`                 | `((a))$` | 移进（`(`，状态 3） | 状态 0 中$A \to \boldsymbol{\cdot} (A)$匹配 `(`，转移到状态 3 |
| 2    | `$0 ( 3`             | `(a))$`  | 移进（`(`，状态 3） | 状态 3 中$A \to \boldsymbol{\cdot}( A)$匹配 `(`，转移到状态 3 |
| 3    | `$0 ( 3 ( 3`         | `a))$`   | 移进（`a`，状态 2） | 状态 3 中$A \to \boldsymbol{\cdot} a$匹配 `a`，转移到状态 2  |
| 4    | `$0 ( 3 ( 3 a 2`     | `))$`    | 归约（$A \to a$）   | 状态 2 是$A \to a \boldsymbol{\cdot}$，弹出 `a`/ 状态 2，回退到状态 3；状态 3 中$A \to (\boldsymbol{\cdot} A)$接受 A，压入 `A`/ 状态 4（$A \to (A \boldsymbol{\cdot} )$） |
| 5    | `$0 ( 3 ( 3 A 4`     | `))$`    | 移进（`)`，状态 5） | 状态 4 中$A \to (A \boldsymbol{\cdot} )$匹配 `)`，转移到状态 5 |
| 6    | `$0 ( 3 ( 3 A 4 ) 5` | `)$`     | 归约（$A \to (A)$） | 状态 5 是$A \to (A) \boldsymbol{\cdot}$，弹出 `(A)`/ 状态 3→4→5，回退到状态 3；状态 3 中$A \to (\boldsymbol{\cdot} A)$接受 A，压入 `A`/ 状态 4 |
| 7    | `$0 ( 3 A 4`         | `)$`     | 移进（`)`，状态 5） | 状态 4 中$A \to (A \boldsymbol{\cdot} )$匹配 `)`，转移到状态 5 |
| 8    | `$0 ( 3 A 4 ) 5`     | `$`      | 归约（$A \to (A)$） | 状态 5 是$A \to (A) \boldsymbol{\cdot}$，弹出 `(A)`/ 状态 3→4→5，回退到状态 0；状态 0 中$A' \to \boldsymbol{\cdot} A$接受 A，压入 `A`/ 状态 1（$A' \to A \boldsymbol{\cdot}$） |
| 9    | `$0 A 1`             | `$`      | 接受                | 状态 1 是$A' \to A \boldsymbol{\cdot}$，输入为空，分析成功   |

**核心逻辑**

$LR (0)$分析通过 **“状态 + 栈”** 跟踪进度：

- **移进**：按终结符转移扩展栈；
- **归约**：按完整项目回退栈，替换为非终结符并跳转状态；
- 增广文法确保 “接受” 唯一（对应$S' \to s\boldsymbol{\cdot}$）

### 四、求法

#### 1. 文法准备

- 将文法转换为增广文法（添加$S' → S$产生式）
- 抄题目

#### 2.画$LR(0)$有限自动机$DFA$

- 项目 0 为增广文法的初始项
- 对每个项目状态的项目圆点：若后面是非终结符，在本项目增加该非终结符的所有初始项
- 输入每一个项目圆点后的符号，转到下一个状态

#### 3.画$LR(0)$分析表

- $LR(0) $分析表由**状态**（用序号表示）、**动作**（移进 / 归约）、**规则**（仅归约填 ）、**输入**（处理终结符，\$）和**$Goto$**（处理非终结符）组成
- 对每个状态查$DFA$，若有出去的箭头，动作为移进，项目对应箭头的终结符 / 非终结符在输入 / $Goto$填入指向的项目序号；若没有出去的箭头，动作为归约，规则为状态对应的完整的产生式

#### 4.判断是否能否用$LR(0)$

即判断是否存在**移进 - 归约冲突**或**归约 - 归约冲突**

**移进 - 归约冲突**：同一状态下，既可以移进终结符，也可以归约某个产生式

**归约 - 归约冲突**：同一状态下，存在多个完整项目（如$A→γ\boldsymbol{\cdot}$和$B→δ\boldsymbol{\cdot}$），导致同一前瞻符号触发不同归约

若存在二者之一，则要用$SLR(1)$分析

#### 5.分析流程

- 步骤、分析栈、输入、动作
- 分析栈初始为$0，每次将分析栈栈顶状态与输入对应填入动作
- 移进：将输入字符入栈，栈顶加入$i$
- 归约：将栈中规则右部对应部分和状态全弹出，将此时栈顶状态和规则左部非终结符对应的$Goto$入栈
- 接受：一般到 $0 增广文法右部1 即可接受

## 5.3 $SLR (1) $语法分析

### 一、简要介绍

#### 1. 核心思想

$SLR (1)$（简单$ LR (1)$）**复用$LR (0)$项目集的$ DFA$**，但通过以下两点提升分析能力：

- **引入 1 个前瞻符号**：利用输入串的**下一个记号**指导移进/归约决策；
- **结合$ Follow $集**：通过非终结符的**$Follow $集合**判断归约的合法性，解决$LR (0)$的冲突（如移进-归约冲突）

#### 2. 算法动作定义

设当前状态为$s$（对应分析栈顶的状态），动作规则如下：

##### （1）移进操作

条件：状态$s$包含项目$A \to \alpha \boldsymbol{\cdot} X\beta$（$X$是终结符），且输入的 **下一个记号恰好是$X$**

动作：
1. 将当前输入记号$X$压入分析栈；
2. 找到包含项目$A \to \alpha X \boldsymbol{\cdot} \beta$ 的状态，将其编号压入栈

##### （2）归约操作（隐含逻辑，“$Follow $集决定归约”）

条件：状态$s$包含**完整项目**$A \to \gamma \boldsymbol{\cdot}$（右部完全匹配）

动作：
1. 检查输入的**下一个记号是否属于$\text{Follow}(A)$**；
2. 若属于：按产生式$A \to \gamma$归约：
   - 弹出栈顶的$\gamma$及其对应状态；
   - 压入非终结符$A$，并根据$Goto$表跳转至$A$对应的新状态；
3. 若不属于：触发语法错误（避免无效归约）

### **二、$SLR (1) $分析算法规则**

#### 1. 归约动作

**触发条件**： 状态$s$包含**完整项目**$A \to \gamma \boldsymbol{\cdot}$，且输入的**下一个记号 ∈ $Follow(A)$**（$\text{Follow}(A)$ 是紧跟$A$的终结符集合）

**特殊情况（接受）**： 若归约规则为增广产生式$S' \to S$（$S$是原文法开始符），且下一个输入记号是`$`（输入结束符），则分析成功（接受）

普通归约流程：

1. 从栈顶弹出符号串**$\gamma$** 及其对应状态（因$ DFA $构造，$\gamma$必在栈顶）；
2. 回退到$ DFA $中启动$\gamma$分析的状态$s'$；
3. 状态$s'$必含项目$B \to \alpha \boldsymbol{\cdot} A\beta$（$A$为归约结果）；
4. 压入$A$到栈，再压入$B \to \alpha A \boldsymbol{\cdot} \beta$对应的状态号（遵循 DFA 转移）

#### 2. 错误处理

若输入的下一个记号 **既不满足移进条件，也不满足归约条件**，则声明语法错误

### **三、$SLR (1) $文法的判定**

若文法应用$SLR (1) $规则时**无歧义**（无移进 - 归约冲突、归约 - 归约冲突），则为**$SLR (1) $文法**

对任意状态$s$，需满足以下两条件：

##### 1. 解决**移进 - 归约冲突**

若状态$s$含项目$A \to \alpha \boldsymbol{\cdot} X\beta$（$X$是终结符），则对任意完整项目$B \to \gamma \boldsymbol{\cdot}$，必须满足：$X \notin \text{Follow}(B)$（否则，“移进$X$” 和 “归约$B \to \gamma$” 会因同一前瞻记号冲突）

##### 2. 解决**归约 - 归约冲突**

若状态$s$含两个完整项目$A \to \alpha \boldsymbol{\cdot}$和$B \to \beta \boldsymbol{\cdot}$，则必须满足：$\text{Follow}(A) \cap \text{Follow}(B) = \emptyset$（否则，同一前瞻记号可能触发两个不同归约，导致歧义）

### 四、解析冲突的消歧规则

#### **1. 冲突分类**

$SLR (1)$（及所有移进 - 归约分析方法）的冲突分为两类：

- **移进 - 归约冲突**：同一状态下，既可以移进终结符，也可以归约某个产生式
- **归约 - 归约冲突**：同一状态下，存在多个完整项目（如$A→γ\boldsymbol{\cdot}$和$B→δ\boldsymbol{\cdot}$），导致同一前瞻符号触发不同归约

#### **2. 消歧规则**

##### （1）移进 - 归约冲突：优先移进

**规则**：当移进和归约冲突时，**始终选择移进**

**合理性**：该规则自然符合“最近嵌套”原则（如$if$语句的悬挂$else$问题），多数移进 - 归约分析器自动应用此规则

##### （2）归约 - 归约冲突：文法设计问题

**特征**：同一前瞻符号触发多个归约，通常（但非绝对）暗示**文法二义性或设计错误**（如产生式冗余、逻辑矛盾）

**解决难度**：需修改文法（如拆分产生式、明确优先级），无法通过简单规则消解

#### **3. 示例：悬挂$ else $的歧义与消歧**

##### （1）文法定义（简化$ if $语句）

增广文法（统一入口）：
$$
\begin{cases}
S \to I \mid \text{other} & \text{（语句：if语句或其他语句）} \\
I \to \text{if}\ S \mid \text{if}\ S\ \text{else}\ S & \text{（if语句：带else或不带else）} \\
\exp \to 0 \mid 1 & \text{（布尔表达式，简化为0/1）}
\end{cases}
$$


##### （2）$Follow $集计算

- $Follow(S)=\{\$,else\}$：$S$后可跟结束符`$`或`else`（如`if$s$else ...`中`S`后跟`else`）
- $Follow(I)=\{\$,else\}$：$I$作为$S$的产生式右部，继承$S$的 Follow 集

##### （3）$DFA $状态的冲突点（状态 5）

状态 5 包含两个关键项目：

- **完整项**：$I→if\ S\boldsymbol{\cdot}$（可归约为$I$，因`else` $∈ Follow(I)$，归约后`else`可紧跟$I$）
- **移进项**：$I→if\ S\boldsymbol{\cdot}else\ S$（可移进`else`，继续匹配完整$if-else$结构）

当输入为`else`时，**移进（匹配else）** 和**归约（将`if S`归约为`I`）** 冲突，触发**移进 - 归约冲突**

##### （4）消歧：优先移进的效果

**规则应用**：选择移进`else`，进入状态6（对应$I→if\ S\boldsymbol{\cdot}else\ S$），确保`else`匹配**最近的未闭合$if$**（符合 “最近嵌套” 原则）

**避免错误**：若选择归约，会提前将`if S`归约为`I`，导致后续`else`无法匹配，触发虚假语法错误

##### （5）$SLR (1) $分析表

状态 5 对输入 `else` 的动作设计**移进（s6）**，而非归约，通过优先移进消解冲突，体现 “最近嵌套” 规则

### 五、求法

#### 1. 文法准备

- 确保文法是增广文法（添加$S' → S$）
- 抄题目

#### 2.画$LR(0)$有限自动机DFA

- 项目 0 为增广文法的初始项
- 对每个项目状态的项目圆点：若后面是非终结符，在本项目增加该非终结符的所有初始项
- 输入每一个项目圆点后的符号，转到下一个状态

#### 3.求所有所有非终结符的$Follow$集

#### 4.画$SLR(1)$分析表

- $SLR(1) $分析表由**状态**（用序号表示）、 **输入表**（输入，处理终结符，\$）和**$Goto$表**（处理非终结符）组成
- 输入表填$r($产生式$)$（归约），$Si$（移进），$Accept$（接受），$Goto$表填数字
- 对每个状态查$DFA$，项目对应箭头的终结符填$Si$（i为指向的项目序号），非终结符填指向的项目序号，状态 1 的“\$”栏填$Accept$，当项目有完整项时，在其对应产生式左部非终结符的$Follow$集的所有元素下填$r($产生式$)$（完整项对应的产生式）

#### 5.分析流程

- 步骤、分析栈、输入、动作
- 分析栈初始为$0，每次将分析栈栈顶状态与输入对应填入动作；输入栈为输入字符串和\$
- $Si（shift i）$：将输入字符入栈，栈顶加入$i$
- $ri（reduce i）$：将分析栈中产生式右部对应部分变成左部对应部分，此时非终结符和栈中其左边的状态对应$Goto$入栈
- $Accept$：一般到$0 增广文法右部 1即可接受

### 六、$SLR (1) $分析能力的局限

#### 1.核心冲突场景

已知文法符号的**$Follow $集**：

- $Follow(S) = \{ \$ \}$（$S$是语句开始符，仅输入结束符`$`能紧跟）
- $Follow(V) = \{ :=, \$ \}$（因$S \to V := E$，`:=`可紧跟$V$；又因$E$可推导为$W$，`$`也可紧跟$V$）

#### 2.$SLR (1) $引发的归约 - 归约冲突

在某状态中，输入符号为 `$` 时：

存在两个完整项目：

1. $S \to \text{id} \boldsymbol{\cdot}$（可归约为$S$）；
2. $V \to \text{id} \boldsymbol{\cdot}$（可归约为$V$）

$SLR (1) $因仅通过**$Follow 集$**判断归约合法性（`$` ∈ $\text{Follow}(S)$ 且`$ `∈ $\text{Follow}(V)$），会触发**归约 - 归约冲突**（同一输入符号`$`需同时归约$S \to \text{id}$和$V \to \text{id}$）

#### 3.冲突本质：$SLR (1) $的方法缺陷

该冲突是**“虚假问题”**，源于$ SLR (1) $的局限性：

- 实际语义中，$V \to \text{id}$的归约应被禁止：变量$V$出现在语句末尾前，必须先匹配`:=`（即`:=`需被移进，而非提前归约$V$）
- 但$SLR (1)$仅依赖Follow 集无法区分“$V$后续是否有`:=`”，导致错误冲突

### 七、$SLR (k) $文法

#### 1. 扩展背景：从$ SLR (1) $到$ SLR (k)$

$SLR (1) $仅利用**1 个前瞻符号**辅助决策，可扩展为**$SLR(k)$**（$k \geq 1$），通过**连续$k$个前瞻符号**细化分析动作

其核心是引入：

- $\text{First}_k(\alpha)$：符号串$\alpha$前$k$个符号的$First$集（描述可能的$k$长度前缀）；
- $\text{Follow}_k(A)$：非终结符$A$后$k$个符号的$Follow$集（描述可能的$k$长度后继）

#### 2. $SLR (k) $分析动作规则

基于$\text{First}_k$和$\text{Follow}_k$，$SLR (k) $定义以下决策规则：

##### （1）移进操作

**条件**： 状态$s$包含项目$A \to \alpha \boldsymbol{\cdot} X\beta$（$X$是终结符$/$记号），且输入串的**后续$k$个符号$w$** 满足：$Xw \in \text{First}_k(X\beta)$

**动作**： 将当前输入记号$X$压入栈，跳转至包含项目$A \to \alpha X \boldsymbol{\cdot} \beta$的状态

##### （2）归约操作

**条件**： 状态$s$包含**完整项目**$A \to \gamma \boldsymbol{\cdot}$，且输入串的 **后续$ k $个符号$ w$** 满足：$w \in \text{Follow}_k(A)$

**动作**： 按产生式$A \to \gamma$ 归约（弹出$\gamma$及其状态，压入$A$并跳转$Goto$状态）

#### 3. 核心意义：增强分析能力

**对比$ SLR (1)$**：$SLR (1) $是$k=1$的特例，$SLR (k) $通过**更长的前瞻窗口**（$k$个符号），能更精准地区分上下文

**代价**：$k$增大时，状态数（项目集数量）指数级增长，实现复杂度飙升，故实际中$k$通常取 1（$SLR (1)$）或借助更高效的$LR $变体（如$LALR (1)$）

## 5.4 通用$LR (1)$与$LALR (1)$语法分析

### 一、$LR (1) $项目的有限自动机

#### 1.$ SLR (1) $的局限与$LR (1)$的突破

**$SLR (1) $的缺陷**：在**$LR (0)$项目集的$DFA$构造完成后**才引入前瞻符号，导致前瞻与状态上下文脱节（如虚假归约冲突）

**$LR (1) $的改进**：从**$DFA$构造的起点就融入前瞻符号**，让状态本身携带 “合法前瞻信息”，精准区分上下文

#### 2.$LR (1)$项目的定义

$LR (1) $项目是**$LR (0)$ 项目 + 单个前瞻记号**的对，形式为：$[A \to \alpha \boldsymbol{\cdot} \beta,\ a]$

- $A \to \alpha \boldsymbol{\cdot} \beta$：$LR (0)$ 项目（圆点标记分析进度）；
- $a$：**前瞻记号**（指示该项目合法的后续输入符号）

#### 3.$LR (1)$自动机的转移规则

$LR (1) $的DFA状态是**$LR (1) $项目的ε-闭包**，转移分**非ε转移**和**ε转移**，核心是**维护前瞻的一致性**：

##### （1）非ε转移（处理显式符号转移，类似 $LR (0)$）

**条件**：存在项目$[A \to \alpha \boldsymbol{\cdot} X\gamma,\ a]$（$X$是任意符号，终结符$/$非终结符）

**转移**：遇符号$X$，转移到$[A \to \alpha X \boldsymbol{\cdot} \gamma,\ a]$（圆点后移，前瞻$a$保持不变）

##### （2）ε转移（处理非终结符的闭包，动态计算新前瞻）

**条件**：存在项目$[A \to \alpha \boldsymbol{\cdot} B\gamma,\ a]$（$B$是非终结符）

**转移**：对$B$的**每个产生式 $B \to \beta$**，以及**每个$b \in \text{First}(\gamma a)$**，添加ε-转移到：$[B \to \boldsymbol{\cdot} \beta,\ b]$

**原理**：$\text{First}(\gamma a)$是 “$\gamma$ 的首符号 + 原前瞻 a” 的可能组合，确保新项目的前瞻符合上下文推导

### 二、$LR (1) $分析算法

设**当前状态$s$**为分析栈顶的$LR (1) $项目集状态，动作规则如下：

#### 1. 移进操作

**条件**： 状态$s$包含$LR (1) $项目$[A \to \alpha \boldsymbol{\cdot} X\beta,\ a]$（$X$是终结符），且输入的**下一个记号为$ X$**

动作：将$X$压入栈，跳转至包含$[A \to \alpha X \boldsymbol{\cdot} \beta,\ a]$ 的状态

#### 2. 归约操作

**条件**： 状态$s$包含完整项目$[A \to \alpha \boldsymbol{\cdot},\ a]$，且输入的**下一个记号为$ a$**（前瞻匹配）

**特殊处理（接受）**： 若归约规则为$S' \to S$（增广产生式）且输入记号为`$`，则分析成功

普通归约流程：

1. 弹出栈顶的$\alpha$及其对应状态，回退到启动$\alpha$分析的状态$s'$；
2. $s'$必含项目$[B \to \alpha \boldsymbol{\cdot} A\beta,\ b]$，压入$A$并跳转至$[B \to \alpha A \boldsymbol{\cdot} \beta,\ b]$对应的状态

##### 3. 错误处理

若输入记号不满足移进$/$归约条件，声明语法错误

### 三、$LR (1) $文法的判定

文法应用$LR (1)$规则**无歧义**（无冲突）时，称为**$LR (1) $文法**

对任意状态$s$，需满足：

#### 1. 移进 - 归约冲突 - free

若$s$含$[A \to \alpha \boldsymbol{\cdot} X\beta,\ a]$（$X$是终结符），则**不存在**$[B \to \gamma \boldsymbol{\cdot},\ X]$（否则移进与归约冲突）

#### 2. 归约 - 归约冲突 - free

$s$中**不能同时存在**两个完整项目$[A \to \alpha \boldsymbol{\cdot},\ a]$ 和$[B \to \beta \boldsymbol{\cdot},\ a]$（否则同前瞻触发不同归约）

### 四、$LR(1)$的求法

#### 1. 文法准备

- 确保文法是增广文法（添加$S' → S$）
- 抄题目

#### 2.画$LR(1)$有限自动机$DFA$

- 项目 0 为增广文法的初始项
- 对每个项目状态的项目圆点：若后面是非终结符，在本项目增加该非终结符的所有初始项
- 输入每一个项目圆点后的符号，转到下一个状态
- 对于每个状态的前瞻记号，项目圆点后为文法开始符，前瞻记号为\$；若为其他，在文法中找所有项目圆点后紧跟左部非终结符的产生式，若非终结符后为空，直接继承其前瞻记号，若不为空，将$First$(非终结符后一个符号)放入前瞻记号
- 项目圆点右移，直接继承前瞻符号
- 在同一个项目中，同一状态，不同前瞻记号，可合并

#### 3.画$LR(1)$分析表

- $LR(1) $分析表由**状态**（用序号表示）、 **输入表**（输入，处理终结符，\$）和**$Goto$表**（处理非终结符）组成
- 输入表填$ri$（归约），$Si$（移进），$Accept$（接受），$Goto$表填数字
- 对每个状态查$DFA$，项目对应箭头的终结符填$Si$（$i$为指向的项目序号），非终结符填指向的项目序号，状态 1 的“\$”栏填$Accept$，当项目有完整项时，在其前瞻记号下填$ri$（$i$为完整项对应的产生式）

### 五、$LALR (1) $解析

#### **1.动机：$LR (1) $的状态冗余问题**

$LR (1) $的$DFA$状态数庞大，源于**“前瞻符号分裂状态”**：许多$LR (1)$状态的**$LR (0)$ 核心**（项目的“分析进度”部分，如$A \to \alpha \boldsymbol{\cdot} \beta$）完全相同，仅**前瞻符号**（如`$`、`)`）不同

#### **2.$LALR (1) $的核心思想：合并 “核心相同” 的状态**

**核心定义**：$LR (1)$项目的**$LR (0)$ 部分**（即去掉前瞻后的项目，如$[A \to \alpha \boldsymbol{\cdot} \beta,\ a]$ 的核心是$A \to \alpha \boldsymbol{\cdot} \beta$）

**合并规则**：将**核心相同的$LR (1)$状态**合并，组合它们的**前瞻符号集合**（而非单个前瞻符号）

#### **3.$LALR (1) $的两个构造原则**

##### （1）核心等价原则

$LALR (1)$状态的**核心**与$LR (0)$的状态完全一致（即核心是$LR (0)$项目集）

##### （2）转移一致性原则

若两个$LALR (1)$状态$s_1, s_2$核心相同，且$s_1$对符号$X$转移到$t_1$，则$s_2$对$X$必转移到**核心与$t_1$相同的状态$t_2$**（保证合并后转移逻辑一致）

#### **4.构造方法：从$LR (1)$到$LALR (1)$的压缩**

1. 生成**$LR (1) $的$DFA$**（含所有分裂的状态）；
2. **识别核心相同的状态**；
3. **合并这些状态**，将它们的**前瞻符号合并为集合**；
4. 最终得到**$LALR (1)$的$DFA$**，每个项目形式为$[\text{LR(0)项目}, \text{前瞻符号集合}]$

$LALR(1) $**同时保留**：

- $LR (1)$的**冲突处理能力**（前瞻集合比$SLR$的$Follow$集更精准，避免虚假冲突）；
- $LR (0)$的**高效性**（状态数未因前瞻分裂爆炸，工程实现友好）

### 六、$LALR (1) $分析：逻辑、构造与优势

#### 1.算法与文法基础

**算法复用**：$LALR(1)$分析流程继承$LR(1)$的**移进、归约、错误处理逻辑**，差异在于：用**合并后的$LALR (1)$状态（核心 + 前瞻集合）**替代$LR(1)$的分裂状态

**文法判定**：若应用$LALR(1)$算法时**无移进 - 归约、归约 - 归约冲突**，则文法为**$LALR(1)$文法** 

#### 2.从$LR(0)$构造$LALR(1)$：前瞻传播

无需构建$LR(1)$庞大$DFA$，通过**前瞻符号传播机制**，从$LR (0)DFA$直接生成$LALR(1)DFA$，步骤如下：

##### （一）初始化：自发生成初始前瞻

对增广项目（如`[A' → ·A, {$}]` ），输入结束符`$`作为**初始合法结束标记**，“自发生成” 为前瞻 

##### （二）ε- 闭包：传播前瞻到非终结符项目

$LR(0)$状态中，非终结符项目（如`A' → ·A`）扩展闭包时，**继承父项目前瞻集合** 

例：`A' → ·A`的闭包含`A → ·(A)`、`A → ·a`，因`A`后无符号，前瞻均为`{ $ }` 

##### （三）转移边：沿符号传播前瞻

跟随$LR(0)$转移边（如状态0→1 via `A`、0→3 via `a`、0→2 via `(` ），**当前状态前瞻集合传播到目标状态核心项目** 

例：状态0的`{ $ }`随转移，传播到状态 1（`A' → A ·` ）、3（`A → a ·` ）、2（`A → (·A)` ） 

##### （四）递归传播：处理嵌套依赖

嵌套结构（如状态2核心`A → (·A)`）因括号闭合需求，**自发生成新前瞻`)`**，形成`{ $, ) }`集合，该集合通过转移边（如状态 2→4 via `A`、2→6 via `a` ）递归传播，覆盖嵌套场景合法前瞻 

#### 3.核心优势：传播 vs 分裂

**$LR(1)$**：通过**分裂状态**处理不同前瞻，导致状态数爆炸

**$LALR(1)$**：通过**传播前瞻集合到核心相同状态**压缩规模，状态数与$LR(0)$相当，且保留$LR(1)$前瞻精准性 

### 七、$LALR(1)$的求法

#### 1. 文法准备

- 确保文法是增广文法（添加$S' → S$）
- 抄题目

#### 2.画$LR(1)$有限自动机$DFA$

- 项目 0 为增广文法的初始项
- 对每个项目状态的项目圆点：若后面是非终结符，在本项目增加该非终结符的所有初始项
- 输入每一个项目圆点后的符号，转到下一个状态
- 对于每个状态的前瞻记号，项目圆点后为文法开始符，前瞻记号为\$；若为其他，在文法中找所有项目圆点后紧跟左部非终结符的产生式，若非终结符后为空，直接继承其前瞻记号，若不为空，将$First$(非终结符后一个符号)放入前瞻记号
- 项目圆点右移，直接继承前瞻符号
- 在同一个项目中，同一状态，不同前瞻记号，可合并

#### 3.画$LR(1)$分析表

- $LR(1) $分析表由**状态**（用序号表示）、 **输入表**（输入，处理终结符，$）和**$Goto$表**（处理非终结符）组成
- 输入表填$ri$（归约），$Si$（移进），$Accept$（接受），$Goto$表填数字
- 对每个状态查$DFA$，项目对应箭头的终结符填$Si$（$i$为指向的项目序号），非终结符填指向的项目序号，状态 1 的“\$”栏填$Accept$，当项目有完整项时，在其前瞻记号下填$ri$（$i$为完整项对应的产生式）

#### 4.合并核心相同的项目

在$LR(1)$分析表的基础上，若两个项目有状态相同或包含关系，合并项目，状态的前瞻记号合并，指向原先项目的箭头指向新项目（以“/”合并）
