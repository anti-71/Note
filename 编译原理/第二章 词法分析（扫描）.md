# 第二章 词法分析（扫描）

**词法分析（Scanning）**

词法分析是编译器的第一步，主要任务是将源代码（由字符组成的文件）分解成一个个**词法单元（tokens）**

**标记（Token）**：源代码中的一个独立单位，表示某种信息。 

​	**例子**：关键词（`if`、`while`）、标识符（变量名）、运算符（`+`、`-`）、数字（`3`、`5`）等

词法分析主要依赖于**正则表达式（Regular Expressions）**和**有限自动机（Finite Automata）**
- **正则表达式**：用来描述字符模式的规则，帮助识别符合某种规则的字符串
- **有限自动机**：一种状态机，用来识别正则表达式定义的模式

词法分析的任务是模式匹配的一种特殊情况

​	**模式匹配**：识别输入中符合特定模式的字符串

## 2.1 词法分析的过程

#### 1.词法单元（Tokens）

**分类**：

- **保留字（Reserved Words）**：如 `if`、`while` 等，具有固定的语义
- **特殊符号（Special Symbols）**：如 `+`、`-`、`*`、`/` 等运算符
- **多字符字符串（Multiple Strings）**：如数字（`NUM`）和标识符（`ID`）

#### 2.标记的属性

- **串值（Lexeme）**：标记的实际字符序列。例如，`+` 是加号运算符的串值
- **数值（Value）**：标记所代表的实际值。例如，数字标记 `32767` 的数值是整数 32767
- **语义信息**：标记所代表的语义含义。例如，`+` 表示加法运算

#### 3.标记记录（Token Record）
词法分析器需要计算标记的属性，以便后续处理。以下是两种常见的数据结构表示：

```c
// 第一种结构
typedef struct {
    TokenType tokenval;  // 标记类型
    char *stringval;     // 串值
    int numval;          // 数值
} TokenRecord;

// 第二种结构（使用联合体）
typedef struct {
    TokenType tokenval;  // 标记类型
    union {
        char *stringval; // 串值
        int numval;      // 数值
    } attribute;
} TokenRecord;
```

#### 4.词法分析器的工作示例
考虑以下C语言代码行：
```c
a[index] = 4 + 2
```

假设这段代码存储在输入缓冲区中，箭头指示下一个输入字符：

```
    a [ i n d e x ]   =   4   +   2
↑
```

当调用 `getToken` 函数时：
1. **跳过空白字符**：词法分析器会跳过前四个空白字符
2. **识别标记**：识别字符串 `a` 作为一个标识符（`ID`）
3. **返回标记**：返回 `ID` 作为下一个标记，输入缓冲区的指针移动到下一个字符

处理后的输入缓冲区：
```
    a [ i n d e x ]   =   4   +   2
      ↑
```

## 2.2 正则表达式（Regular Expressions）

### 一、正则表达式的定义

正则表达式是一种用来描述字符模式的逻辑公式。它可以帮助我们识别符合某种规则的字符串
- **语言（Language）**：正则表达式生成的所有字符串的集合称为“语言”，记作 \( L(r) \)
- **字母表（Alphabet）**：正则表达式使用的字符集合，通常用希腊字母 \( $\Sigma$ \) 表示

  ​	例如，\( $\Sigma = \{a, b, c\}$ \) 表示可用的字符是 `a`、`b` 和 `c`

#### **1.基本正则表达式**
- **单字符**：基本正则表达式可以是一个单字符 `a`（其中 `a` 是字母表 \( $\Sigma$ \) 中的一个字符）
  
  ​	\( $L(a) = \{a\}$ \)
- **空字符串（ε）**：表示没有字符的字符串
  
  ​	\( $L(\varepsilon) = \{\varepsilon\}$ \)
- **空集（Φ）**：表示不匹配任何字符串
  
  ​	\( $L(\Phi) = \{\} $\)

#### **2.正则表达式操作**
1. **选择（Union）**：用 `|` 表示“或”的关系
   
   ​	 $L(r|s) = L(r) \cup L(s) $

2. **连结（Concatenation）**：将两个正则表达式连接起来，表示它们的组合
   
   ​	$ L(rs) = L(r) \cdot L(s) $
   
3. **闭包（Closure）**：用 `*` 表示“零个或多个”的关系
   
   ​	$ L(r*) = (L(r))^* $

#### **3.运算优先级和括号的使用**
**优先级**：  

1. 闭包（`*`）  
2. 连接（`rs`）  
3. 选择（`|`）  

​	`a|bc*` 被解释为 `a|(b(c*))`

**括号的使用**：括号可以改变运算的优先级

#### **4.正则表达式的命名**
为复杂的正则表达式命名可以提高可读性

`digit = 0|1|2|3|4|5|6|7|8|9`  

`(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*`表示为`digit digit*` 更简便

### **二、正则表达式扩展功能**

#### **1.一次或多次重复（`r+`）**
匹配一个或多个 `r`

`(0|1)+` ：表示一个或多个 `0` 或 `1` 的组合，等价于 `(0|1)(0|1)*`

#### **2.任意字符（`.`）**
匹配任意单个字符

`.*b.*`：表示包含 `b`的任意字符串

#### **3.字符范围（`[ ]`）**
匹配指定范围内的字符

`[0-9]`：匹配任意数字

`[a-zA-Z]`：匹配任意大小写字母

`[a-z]`：匹配任意小写字母

#### **4.否定字符集（`[^ ]`）**
匹配不在指定集合中的字符

`[^abc]`：匹配不是 `a`、`b` 或 `c` 的字符

`[^0-9]`：匹配不是数字的字符

#### **5.可选子表达式（`r?`）**
匹配零个或一个 `r`

`(+|-)? natural`：表示可选的正号或负号，后跟一个自然数

### **三、正则表达式在编程语言标记中的应用**

#### **1.数字（Numbers）**
- **自然数（Natural Numbers）**：  
  
  ```regex
  nat = [0-9]+
  ```
  表示一个或多个数字
  
- **带符号的自然数（Signed Natural Numbers）**：  
  
  ```regex
  signedNat = (+|-)? nat
  ```
  表示可选的正号或负号，后跟一个自然数
  
- **浮点数（Floating-Point Numbers）**：  
  ```regex
  number = signedNat (“. ”nat)? (E signedNat)?
  ```
  表示一个浮点数，可以包含小数部分和指数部分

#### **2.保留字和标识符（Reserved Words and Identifiers）**
- **保留字（Reserved Words）**：  
  
  ```regex
  reserved = if | while | do | ...
  ```

- **字母（Letters）**：  
  ```regex
  letter = [a-z A-Z]
  ```
  表示一个字母（大小写）

- **数字（Digits）**：  
  ```regex
  digit = [0-9]
  ```
  
- **标识符（Identifiers）**：  
  ```regex
  identifier = letter (letter | digit)*
  ```
  表示一个标识符，以字母开头，后面可以是字母或数字的组合

#### **3.注释（Comments）**
- **C语言注释**：  
  ```regex
  /* this is a C comment */
  ```
  
- **Pascal注释**：  
  
  ```regex
  { this is a pascal comment }
  ```
  正则表达式：  
  ```regex
  { (~})* }
  ```
  
- **Scheme注释**：  
  
  ```regex
  ; this is a schema comment
  ```
  正则表达式：  
  ```regex
  ; (~newline)* newline
  ```
  其中 `newline` 表示换行符 `\n`
  
- **Ada注释**：  
  ```regex
  -- this is an Ada comment
  ```
  正则表达式：  
  ```regex
  -- (~newline)* newline
  ```

#### **4.特殊情况：否定字符串“ab”**
**问题**：由于“非”运算通常限制为只能是单个字符，如何表示字符串“ab”的否定？  

使用 `~a`、`~b` 和 `~(a|b)` 来组合出对字符串“ab”的否定

### **三、词法分析中的二义性、空白字符和前瞻**

#### **1.二义性（Ambiguity）**
某些字符串可能被多个不同的正则表达式匹配

**处理方法**：

1. **关键字优先**：当一个字符串既可以被解释为标识符，也可以被解释为关键字时，通常优先选择关键字解释
2. **最长子字符串原则**：当一个字符串可以被解释为单个标记或多个标记的序列时，通常选择最长的子字符串作为单个标记

#### **2.空白字符（White Space）**
空白字符是明确作为其他标记分隔符的字符

**常见空白字符**：换行符（newline）、空格（blank）、制表符（tab）和注释（comment）

```regex
whitespace = (newline | blank | tab | comment)+
```

#### **3.前瞻（Lookahead）**
在语法分析过程中，分析器根据当前已经扫描过的标记流和尚未扫描的标记，确定如何分析句子

**级别**：

​	**Lookahead 1**：只查看一个尚未处理的标记即可确定下一步分析

​	**Lookahead 2**：需要查看两个尚未处理的标记才能确定下一步分析

​	依此类推

#### **4.输入字符的缓冲和回溯（Buffering and Backtracking）**
**缓冲**：为了高效处理输入字符，通常会将输入字符缓冲起来

**回溯**：在某些情况下，可能需要回溯到之前的位置重新处理字符

## **2.3 有限自动机（Finite Automata）**

有限自动机（finite automata，也称为有限状态机）是一种数学方法，用于描述特定类型的算法

**有限自动机的组成部分**：

- **状态（States）**：有限自动机的不同“位置”
- **转移（Transitions）**：记录从一个状态到另一个状态的变化，当匹配到特定字符时发生
- **开始状态（Start State）**：识别过程的起点，通常用一个未标记的箭头指向它
- **接受状态（Accepting States）**：表示识别过程的终点，通常在图中用双线边框表示

**标识符的有限自动机**：

- **状态1**：开始状态
- **状态2**：接受状态  
- **转移条件**：  
  - 从状态1到状态2：匹配一个字母（`letter`）  
  - 在状态2中循环：匹配一个字母或数字（`letter` 或 `digit`）

<img src="D:\Note\编译原理\Assets\标识符有穷自动机.png" style="zoom: 50%;" />

### **一、确定性有限自动机（DFA）**

#### **1.DFA的定义**
**确定性有限自动机（DFA）**：一种状态机，其中下一个状态由当前状态和当前输入字符唯一确定

**组成部分**：

- **字母表（Alphabet）**：可用的字符集合，记作 $\Sigma $
- **状态集（States）**：有限的状态集合，记作 $ S $
- **转移函数（Transition Function）**：$T: S \times \Sigma \rightarrow S $，定义状态之间的转移
- **开始状态（Start State）**：初始状态，记作  $s_0 \in S $
- **接受状态（Accepting States）**：表示识别过程结束的状态集合，记作 $A \subset S $

**确定性有限自动机（DFA）的特性**

- **状态集的灵活性**：DFA的状态集$S$不局限于数字，可以是任何有限集合

- **转移标签的命名**：转移标签可以是代表字符集合的名称，而不仅仅是单个字符

​	`letter` 代表所有字母，`digit` 代表所有数字

- **转移函数的完整性**：转移函数 $:S×Σ→S $必须对每个状态和输入字符都有定义

#### **2.DFA的接受语言**

DFA接受的语言 \( $L(M)$ \) 是所有字符串的集合，这些字符串满足以下条件：

- 每个字符 $c_i$ 属于字母表  $\Sigma$ 
- 存在状态序列  $s_1, s_2, \ldots, s_n$ ，使得：
  - $ s_1 = T(s_0, c_1) $
  - $ s_2 = T(s_1, c_2) $
  - ...
  - $s_n = T(s_{n-1}, c_n) $
- 最终状态 $ s_n $ 是接受状态

#### 3.典型操作
1. **状态转换时**：将字符从输入字符串移动到一个累积字符串，该字符串包含属于单个token的字符（token的字符串值或词素）
   
2. **到达接受状态时**：返回刚刚识别的token及其关联的属性
   
3. **到达错误状态时**：要么在输入中回退（回溯），要么生成一个错误token

**错误状态**并不是真正的错误，而是表示以下两种情况：

1. 如果从初始状态进入，则标识符未被识别
2. 如果从其他状态进入，则分隔符已被识别，此时应接受并生成一个标识符token

**[other]**：表示分隔符字符应被视为前瞻字符，应将其返回到输入字符串中，而不是消耗掉

**最长子字符串原则**：DFA会继续匹配字母和数字（在状态`in_id`中），直到找到分隔符

### 二、非确定有限自动机（NFA）

#### 1.NFA的基本概念
NFA允许多个转换从一个状态出发，针对同一个字符

NFA可以通过ε转换（空转换）在不消耗输入字符的情况下进行状态转换

#### 2.ε转换
ε转换可以在不查看输入字符串（也不消耗任何字符）的情况下发生

ε转换可以视为对空字符串的匹配

**ε转换的好处*

- **选择替代方案**：

  - ε转换可以不用合并状态就表达另一个选择

  - 优势：保持原始自动机的完整性，只需添加一个新的开始状态来连接它们

- **明确空字符串的匹配**：
  - ε转换可以明确地描述空字符串的匹配

#### 3.NFA的定义
**字母表（Σ）**：输入字符的集合

**状态集合（S）**：自动机可能处于的状态

**转换函数（T）**：定义为 $T: S \times (\Sigma \cup \{\epsilon\}) \rightarrow \mathscr{P}(S) $，其中 $\mathscr{P}(S)$ 是状态集合的幂集

**初始状态（s₀）**：自动机的起始状态

**接受状态集合（A）**：自动机的接受状态

**语言接受（L(M)）**：由NFA $M $ 接受的语言定义为字符序列 $c_1c_2 \ldots c_n $，其中每个 $c_i $ 属于 $ \Sigma \cup \{\epsilon\} $，并且存在状态序列 $ s_1, s_2, \ldots, s_n $使得：

- $s_1 \in T(s_0, c_1) $
- $ s_2 \in T(s_1, c_2) $
- ...
- $ s_n \in T(s_{n-1}, c_n) $
- $ s_n $是接受状态集合 $A $ 中的元素

**注意事项**

1. **ε转换的处理**：
   - 在字符序列 $c_1c_2 \ldots c_n $中，任何 $ c_i $ 都可能是 ε
   - 真正被接受的字符串是删除了 ε 的序列 $ c_1c_2 \ldots c_n $
   - 因此，字符串 $c_1c_2 \ldots c_n $ 中的实际字符数可能少于 $ n $个

2. **非确定性**：
   - 状态序列 $ s_1, s_2, \ldots, s_n $是从状态集合 $ T(s_0, c_1), \ldots, T(s_{n-1}, c_n) $ 中选择的，这种选择并不总是唯一的
   - 这就是为什么称这些自动机为非确定性的原因：接受特定字符串的转换序列并不由状态和下一个输入字符在每一步中确定下来

3. **ε转换的引入**：
   - 任意 ε 都可以在任一点上被引入到字符串中，并与NFA中 ε 转换的数量相对应
   - 因此，NFA并不表示算法，但可以通过一个在每个非确定性选择中回溯的算法来模拟它

#### 4.确定与非确定自动机的不同

- **转换状态不同**:

  - **确定的有穷自动机**：当一个状态面对一个输入符号时，转换到的是一个唯一确定的状态

  - **不确定的有穷自动机**：当一个状态面对一个输入符号时，可能转换到多个状态，即一个状态集合

- **映射不同**:

  - **确定的有穷自动机**：

    - 转换函数将 *S*×Σ 映射到 $S$

    - 对于状态 *s*∈*S* 和输入符号 *a*∈Σ，*δ*(*s*,*a*) 表示从状态 *s* 出发，沿标记为 *a* 的边到达的状态

  - **不确定的有穷自动机**：

    - 转换函数将 *S*×Σ 映射到 $2^S$

    - 对于状态 *s*∈*S* 和输入符号 *a*∈Σ，*δ*(*s*,*a*) 表示从状态 *s* 出发，沿标记为 *a* 的边到达的状态集合

### 三、有限自动机在代码中的实现

<img src="D:\Note\编译原理\Assets\自动机在代码中的实现.png" style="zoom: 33%;" />

#### 1.有限自动机在代码实现中的缺点

**特例性**：每个DFA都需要特殊处理，难以找到一种适用于所有DFA的通用算法

**代码复杂度增加**：随着状态数量的增加，或者更具体地说，随着任意路径上不同状态数量的增加，代码的复杂度会急剧上升

#### 2.更好的方法

通过一个变量来保持当前状态，并将转换写成一个双重嵌套的case语句，放在循环内部。其中，第一个case语句测试当前状态，嵌套的第二个级别测试输入字符

## 2.4 从正则表达式到DFA的转换

**转换算法**：将正则表达式转换为NFA，再将NFA转换为DFA，最后将DFA转换为程序

**Thompson构造法**：使用ε转换将正则表达式的每个部分的机器“粘合”在一起，形成一个与整个表达式对应的机器

### 一、从正则表达式到NFA的转换

#### 1. 基本正则表达式

- **单个字符（a）**：
  - 构造一个简单的NFA，包含两个状态，一个初始状态和一个接受状态，中间有一个标记为a的转换
  
- **空字符串（ε）**：
  - 构造一个简单的NFA，包含两个状态，一个初始状态和一个接受状态，中间有一个ε转换
  
- **空集（∅）**：
  - 构造一个NFA，初始状态没有转换到任何其他状态，因此无法接受任何字符串

#### 2. 连接操作（Concatenation）
**表达式**：`rs`

**构造方法**：将r的接受状态通过ε转换连接到s的初始状态

- 新机器的初始状态是r的初始状态
- 新机器的接受状态是s的接受状态
- 这个机器接受的语言是 $L(rs) = L(r)L(s) $

#### 3. 选择操作（Choice）
**表达式**：`r|s`

**构造方法**：
- 创建一个新的初始状态，通过ε转换连接到r和s的初始状态
- 创建一个新的接受状态，通过ε转换连接r和s的接受状态
- 这个机器接受的语言是 $ L(r|s) = L(r) \cup L(s) $

#### 4. 闭包操作（Repetition）
**表达式**：`r*`

**构造方法**：
- 创建一个新的初始状态和一个新的接受状态
- 通过ε转换将初始状态连接到r的初始状态，并将r的接受状态连接到接受状态
- 通过ε转换将r的接受状态连接回r的初始状态，以允许任意次数的重复
- 这个机器接受的语言是 $L(r*) = (L(r))^* $

#### 5. 正闭包（r+）
**表达式**：`r+`

**构造方法**：
- 类似于闭包操作，但至少匹配一次r
- 这个机器接受的语言是 $ L(r+) = (L(r))^+ $

### 二、从NFA到DFA的转换

#### 1.转换目标

- 给定一个任意的NFA，构造一个等价的DFA（即接受完全相同字符串的DFA）

#### 2.需要解决的问题
**消除ε转换**：

​	**ε闭包**：从一个状态或多个状态出发，通过零次或多次ε转换可以到达的所有状态的集合

**处理单个输入字符的多条转换**：跟踪通过匹配单个字符可以到达的状态集合

### 3.子集构造法

1. **计算初始状态的ε闭包**：
   - 计算NFA初始状态的ε闭包，这个集合成为DFA的初始状态

2. **计算转换**：
   - 对于每个状态集合 $S $ 和输入字符 $ a $，计算集合 $S'_a = \{ t \mid \text{对于某个 } s \in S \text{，存在从 } s \text{ 到 } t \text{ 的 } a \text{ 转换} \} $
   - 计算 $\overline{S'_a} $，即 $ S'_a $ 的ε闭包。这定义了子集构造中的一个新状态和一个新的转换 $ S \xrightarrow{a} \overline{S'_a} $

3. **继续直到没有新状态或转换**：
   - 重复上述过程，直到不再产生新的状态或转换
   - 将包含NFA接受状态的状态集合标记为DFA的接受状态

### 三、DFA的状态最小化

由正则表达式生成的DFA可能比实际需要的复杂得多。例如，对于正则表达式 $a^* $，生成的DFA可能包含多个状态，但实际上可以用更少的状态实现相同的功能

**最小化过程**

1. **初始分组**：
   - 将状态分为非接受状态组和接受状态组。例如，分组为 $\{A, B, C, D\}$ 和 $\{E\}$

2. **分割**：
   - 组 $\{E\}$ 只包含一个状态，无法再分割
   - 对于组 $\{A, B, C, D\}$，考虑输入字符 $a$ 和 $b$ 的行为：
     - 输入 $a$ 时，所有状态都转换到组$\{A, B, C, D\}$中的某个状态，无法区分
     - 输入 $b$ 时，状态 $A, B, C$转换到组 $\{A, B, C, D\}$ 的成员，而状态 $D$ 转换到组 $\{E\}$ 的成员。因此，将  $\{A, B, C, D\}$分割为 $\{A, B, C\}$和 $\{D\}$

3. **再次分割**：
   - 考虑组 $\{A, B, C\}$：
     - 输入 $b$ 时，状态 $A, C$ 转换到组$\{A, B, C\}$的成员，而状态 $B$转换到组 $\{D\}$的成员。因此，将 $\{A, B, C\}$ 分割为 $\{A, C\}$和 $\{B\}$

4. **分割完成**：
   - 最终的状态组为 $\{A, C\}$, $\{B\}$, $\{D\}$, $\{E\}$

5. **最小DFA**：
   - 从每个状态组中挑选一个代表状态，构建最小DFA
