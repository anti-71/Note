# 第三章 上下文无关文法与解析

**解析**是一项确定程序的语法或结构的任务，因此也被称为**语法分析**

编程语言的语法通常由上下文无关文法规则给出

上下文无关文法规则是递归的

用于识别这些结构的算法也与扫描算法有很大不同，因为它们必须使用递归调用或显式管理的解析栈，经常使用的基本结构是一类树，称为**分析树**（parse tree）或**语法树**（syntax tree）

## 3.1 解析过程

**解析器**可以被视为一个函数，其输入是由扫描器生成的记号序列，输出是语法树

- **单遍编译器**中的解析器：单遍编译器中的解析器会合并编译器的所有其他阶段，包括代码生成
  因此，不需要显式地构造语法树（解析步骤本身隐式地表示了语法树），由此就发生了一个 `parse()` 调用
- **多遍编译器**中的解析器：在编译器中更多的是多遍，此时后面的遍将语法树作为它们的输入

**解析器与扫描器的错误处理**

解析器在处理错误方面比扫描器更为困难

- **扫描器中的错误**：生成一个错误记号并消耗掉导致错误的字符
- **解析器中的错误**：解析器不仅要报告错误信息，还必须从错误中恢复并继续解析（尽可能多地发现错误）
  有时，解析器可能会进行错误修复

## 3.2 上下文无关文法

**上下文无关文法**是编程语言语法结构的一种规范，这种规范与使用正则表达式规范语言的词法结构非常相似，但上下文无关文法涉及递归规则

上下文无关文法用于说明程序设计语言的语法结构

### 一、与正则表达式符号的比较

文法规则与正则表达式符号具有相似的表示法：

1. 名字用斜体表示（但使用不同的字体，以便与正则表达式的名字区分开）
2. 竖线（|）仍然作为选择的元符号
3. 并置（concatenation）也被用作标准运算
4. 没有重复的元符号（如正则表达式中的星号*）
5. 使用箭头符号（→）代替等号来表示名字的定义
   这是因为现在的名字不能简单地由其定义取代，而需要更复杂的定义过程，这是由于定义的递归本质决定的
6. 文法规则使用正则表达式作为组成部分

这种形式的文法规则通常被称为**巴科斯范式**（Backus-Naur form，**$BNF$**）

### 二、上下文无关文法规则的规范

与正则表达式类似，文法规则是定义在一个**字母表或符号集**之上的

在正则表达式中，这些符号通常是**字符**，而在文法规则中，符号通常是表示**字符串的记号**

假设有一个字母表，$BNF$中的上下文无关文法规则是由符号串组成

第一个符号是结构名称，第二个符号是元字符$→$，之后是一个符号串，该串中的每个符号都是字母表中的一个符号（即一个结构的名称）或是元符号"|"

我们通常会将文法规则写成这样的形式：所有选择都列在单个规则中，每个结构名称在箭头左边只出现一次，例如：
$$
exp op→exp\ op\ exp∣(exp)∣number\\
op→+∣−∣∗
$$
我们使用大写字母表示结构名称，小写字母表示单独的记号符号（通常是单个字符）

因此，我们的简单表达式文法可以简写为：
$$
E\to E\ O\ E\ \lvert\ (E)\ \rvert\ n\\
O\to +\ |\ -\ |\ *
$$

### 三、推导与文法定义的语言

#### 1.文法规则如何确定语言

**推导（Derivation）**：文法规则通过推导确定合法的记号符号串

- 推导是结构名称替换的序列，替换基于文法规则右边的选择
- 推导从一个结构名称开始，以记号符号串结束
- 在推导的每一步中，使用文法规则的一个选择进行替换

`(34-3)*42` 对应于七个记号的合法字符串：
$$
(number−number)∗number
$$
而 `(34-3*42)` 不是合法的表达式，因为左边的括号没有对应的右括号。文法规则中 `exp` 的第二个选择要求括号必须成对出现

#### 2.推导示例

`(34-3)*42`

1. $exp⇒exp\ op\ exp  [exp→exp\ op\ exp]$
2. $⇒exp\ op\ number  [exp→number]$
3. $⇒exp∗number  [op→∗]$
4. $⇒(exp)∗number  [exp→(exp)]$
5. $⇒(exp\ op\ exp)∗number  [exp→exp\ op\ exp]$
6. $⇒(exp\ op\ number)∗number  [exp→number]$
7. $⇒(exp−number)∗number  [op→−]$
8. $⇒(number−number)∗number  [exp→number]$

#### 3.语言定义

由文法定义的语言$ L(G) $是从开始符号$ exp $通过推导得到的所有记号符号串的集合：
$$
L(G)={s∣exp⇒^*s}
$$

1. **$G$** 表示表达式文法
2. $s$表示任意记号符号串（有时称为句子）
3. $⇒^∗$ 表示由一系列替换组成的推导
   星号表示步骤序列，类似于正则表达式中的重复
4. 文法规则有时称为产生式，因为它们通过推导“产生”$ L(G) $中的字符串

#### 4.文法符号

**开始符号**：文法规则中最一般的结构首先列出

**非终结符**：结构名称也称为非终结符，因为它们在推导中必须被进一步替换

**终结符**：字母表中的符号称为终结符，因为它们终止推导

​		在编译器应用中，终结符通常是记号

#### 5.左递归与右递归

**左递归（Left Recursive）**：非终结符$A$出现在定义$A$的规则右边的第一个符号位置

- 示例：$A→A\ a∣a$

**右递归（Right Recursive）**：非终结符$A$出现在定义$A$的规则右边的最后一个符号位置

- 示例：$A→a\ A∣a$

#### 6.ε-产生式

为了生成与正则表达式 `a*` 相同的语言，必须有一种表示生成空字符串的文法规则（因为正则表达式 `a*` 可以匹配空字符串）

可以在规则右边不写任何内容：
$$
Empty→
$$
但通常使用空字符串的元符号 ε（类似于正则表达式中的用法）：
$$
empty→ε
$$
这样的文法规则称为**ε-产生式**

如果一个文法生成的语言包含空字符串，则该文法必须至少有一个ε-产生式

## 3.3 解析树和抽象语法树

**推导的非唯一性**：推导并不唯一地表示它们所构造的字符串的结构

通常，对于同一个字符串，可能存在许多不同的推导方式

不同的推导路径可能对应不同的解析树结构，但最终生成的字符串相同

### 一、解析树

#### 1.解析树的定义

解析树是对应于推导的标记树，其中：

- 内部节点由非终结符标记
- 叶节点由终结符标记
- 每个内部节点的子节点表示在推导步骤中替换相应非终结符的方式

例如，推导 `exp => exp op exp => number op exp => number + exp => number + number` 对应的解析树如下：

           exp
          / | \
       exp op exp
        |   |   |
     number + number
#### 2.解析树与推导

同一个解析树通常对应于许多推导，所有这些推导都代表了解析字符串的相同基本结构

可以区分出与解析树唯一相关的特定推导：

- **最左推导（Leftmost Derivation）**：在每一步推导中替换最左边的非终结符
  对应于其相关解析树的内部节点的前序编号
- **最右推导（Rightmost Derivation）**：在每一步推导中替换最右边的非终结符
  对应于其相关解析树的内部节点的后序编号

#### 3.解析树示例

对于表达式 `(34-3)*42` 的解析树：

```
        exp
       / | \
     exp op exp
     |   |   |
  ( exp ) * number
    / | \
number - number
```

此解析树可以对应最左推导或最右推导

### 二、抽象语法树

#### 1.抽象语法树的定义

**抽象语法树**（Abstract Syntax Tree, **AST**）是源代码的抽象表示

它表示程序的结构，忽略了某些细节，如括号和运算符的优先级

$AST$节点表示语句、表达式或程序的其他组成部分

示例：表达式 `(34-3)*42`

```
    *
   / \
  -  42
 / \
34  3
```

#### 2.抽象语法树的特点

1. **信息精简**：

$AST$省略了括号等不影响语义的细节，但保留了所有翻译所需的信息

无法从$AST$恢复原始的记号序列，但它更高效地表示了程序的结构

2. **语法抽象**：

解析树表示具体的语法结构，而$AST$表示抽象的语法结构

3. **形式化定义**：

抽象语法可以用类似$BNF$的符号形式化定义：
$$
\begin{align*}
\text{exp} &\rightarrow \text{OpExp(op, exp, exp)} \mid \text{ConstExp(integer)} \\
\text{op} &\rightarrow \text{Plus} \mid \text{Minus} \mid \text{Times}
\end{align*}
$$

#### 3.抽象语法树的节点类型

**操作符节点**：表示操作（如加、减、乘）

**常量节点**：表示整数常量

**其他字段**：在实际应用中，通常会有更多字段用于存储编译时属性，如数据类型、符号表信息等

## 3.4 歧义性

语法可能允许一个字符串具有多个不同的语法分析树

考虑我们一直使用的简单整数算术语法，字符串 `34 - 3 * 42`有两个不同的语法分析树

### 一、模糊语法

#### 1.模糊语法定义

如果一个语法可以生成具有两个不同语法分析树的字符串，则称该语法是**模糊**的

这样的语法对解析器来说是一个严重的问题，因为它没有明确指定程序的句法结构（即使语法的语言所确定的合法字符串本身是完全确定的）

在某种意义上，模糊语法类似于非确定性自动机，其中两条不同的路径可以接受同一个字符串

然而，与自动机中的非确定性不同，语法中的模糊性不能轻易地被移除，因为没有算法可以做到这一点

#### 2.处理模糊性的两种基本方法

1. **制定去歧义规则**：在每个模糊的情况下，指定哪个语法分析树是正确的，这种规则称为**去歧义规则**
   - 优点：它纠正了模糊性而不改变（并可能复杂化）语法
   - 缺点：语言的句法结构不再由语法单独给出
2. **修改语法**：将语法修改为强制构造正确的语法分析树，从而消除模糊性

#### 3.解决模糊性的关键

在任何方法中，我们首先必须决定在模糊的情况下哪个树是正确的

#### 4.非结合性操作

还可以指定操作是非结合的，即表达式中不允许出现多个操作符的序列

例如，我们可以将简单表达式语法写成以下形式：

- `exp → factor op factor | factor`
- `factor → ( exp ) | number`
- `op → + | - | *`

在这种情况下，像 `34 - 3 - 42` 甚至 `34 - 3 * 42` 这样的字符串现在是非法的，必须用括号写出

### 二、优先级和结合性

#### 1.优先级级联

将运算符分组到不同的优先级级别是使用$BNF$进行语法说明时的一个标准方法，这种分组称为**优先级级联**（precedence cascade）

| 原文法                                                  | 修改后的文法                                                 |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| $exp → exp\ op\ exp | (exp) | number\\ op  → + | - | *$ | $exp     → exp\ addop\ exp | term \\addop   → + | -\\ term    → term\ mulop\ term | factor      \\mulop   → * \\factor  → (exp) | number  $ |

在这个文法中，乘法被归在 `term` 规则下，而加法和减法则被归在 `exp` 规则之下

加法和减法在解析和语法树中会出现在“更高的”位置（即更靠近根节点），因此具有较低的优先级

#### 2.结合性

简单算术表达式的最后一种文法仍未指出运算符的结合性，且仍有歧义

原因在于运算符两边的递归都允许每一边匹配推导（因此也在分析树和语法树）中的运算符重复

解决方法是用基本情况代替递归，强制重复运算符匹配一边的递归：

- 将规则 `exp → exp addop exp | term` 替换为 `exp → exp addop term | term`，使得加法和减法左结合
- 将规则 `exp → exp addop exp | term` 替换为 `exp → term addop exp | term`，使得它们右结合

#### 3.消除歧义的完整规则

为完成对简单算术表达式$BNF$规则中歧义的消除，我们编写规则以使所有操作左结合：

| 原文法                                    | 修改后的文法                                                 |
| :---------------------------------------- | :----------------------------------------------------------- |
| $exp→exp\ op\ exp∣(exp)∣number\\op→+∣−∣∗$ | $exp→exp\ addop\ term∣term\\addop→+∣-\\term→term\ mulop\ factor∣factor\\mulop→∗\\factor→(exp)∣number$ |

表达式 `34 - 3 * 42` 的解析树：

```
            exp
       /     |         \
   exp    addop        term
    |       |       /    |    \
  term      -    term mulop factor
   |                |    |     |
factor           factor  *   number
  |                 |    
number            number 
```

优先级级联使得解析树变得更加复杂，但语法树不受影响

### 三、悬挂的 else 问题

#### 1.问题描述

考虑以下文法：

```
statement → if-stmt | other
if-stmt → if ( exp ) statement | if ( exp ) statement else statement
exp → 0 | 1
```

这个文法由于可选的 `else` 部分而产生歧义

例如，字符串 `if (0) if (1) other else other` 可以有两种不同的语法分析树：

1. 第一个分析树将 `else` 部分与第一个 `if` 语句关联
2. 第二个分析树将 `else` 部分与第二个 `if` 语句关联

这种歧义称为**悬挂的else问题**

#### 2.正确性判断

选择哪一个分析树是正确的，取决于我们希望将单独的 `else` 部分与第一个还是第二个 `if` 语句关联

通常情况下，我们希望将 `else` 部分与最近的没有 `else` 的 `if` 语句关联，这种去歧义规则被称为**最接近嵌套规则**（most closely nested rule），它表明第二个分析树是正确的

#### 3.修改后的文法

为解决悬挂的 `else` 问题，可以修改文法如下：

```
statement → matched-stmt | unmatched-stmt
matched-stmt → if ( exp ) matched-stmt else matched-stmt | other
unmatched-stmt → if ( exp ) statement | if ( exp ) matched-stmt else unmatched-stmt
exp → 0 | 1
```

对于字符串 `if (0) if (1) other else other`，修改后的文法生成的解析树如下：

```
        statement
          |
    unmatched-stmt
      /   / | \        \
   if    ( exp )     statement
            |               |
            0           matched-stmt
              /  / /  /      |       \      \
             if ( exp ) matched-stmt else matched-stmt
                   |         |                  | 
                   1        other             other
```

#### 4.悬挂的 else 问题的起源与解决方法

悬挂的 `else` 问题起源于$Algol60 $的语法

可以通过以下方法设计语法以避免此问题：

1. **要求存在 `else` 部分**：此方法已在$ LISP $和其他函数式语言中使用（其中还必须返回一个值）
2. **使用括号关键字**：此方法在$ Algol68 $和$ Ada $等语言中使用

### 四、非本质歧义

有时，一个文法可能是模糊的，但总是产生唯一的抽象语法树，这种模糊性可以称为**非本质歧义**

非本质歧义是指相关的语义不依赖于使用哪种去歧义规则

例如，算术加法或字符串连接代表结合运算（如果对于所有值$a、b $和$ c$，有$ (a⋅b)⋅c=a⋅(b⋅c)$，则二元运算"$ ⋅ $"是结合的）

在这种情况下，语法树虽然不同，但表示相同的语义值，我们可能不关心使用哪一个

## 3.5 扩展表示法：$EBNF$ 和语法图

### 一、$EBNF$ 表示法

$BNF$ 表示法有时会扩展为包含用于重复和可选结构的特殊符号，这些扩展被称为**扩展 $BNF$**（**$EBNF$**）

#### 1.重复

左递归：
$$
A→Aα∣β
$$
右递归：
$$
A→αA∣β
$$
其中，$α $和$ β $是任意的终结符和非终结符的字符串，并且在第一条规则中$β$不以$A$开头，在第二条规则中$β$不以$A$结尾

$EBNF$ 使用花括号 `{...}` 来表示重复结构

例如：

左递归：
$$
A→β\{α\}
$$
右递归：
$$
A→\{α\}β
$$

#### 2.可选结构

$EBNF$ 使用方括号 `[...]` 来表示可选结构

例如：

$if $语句的文法规则可以写成：
$$
if−stmt→if(exp)statement[elsestatement]
$$

#### 3.结合性

$EBNF$ 还可以表示结合性：

左结合：
$$
exp→term\{addop\ term\}
$$
右结合：
$$
exp→\{term\ addop\}term
$$

### 二、语法图

#### 1.语法图介绍

语法图是一种用于直观表示$EBNF$规则的图形表示法，它包括以下元素：

1. **表示终结符和非终结符的框**：

   圆形或椭圆形框用于表示终结符

   矩形框用于表示非终结符

2. **表示顺序和选择的箭头线**：

   箭头线用于表示元素的顺序和选择关系

3. **每个图的非终结符标签**：

   每个语法图都有一个非终结符标签，表示该图定义的非终结符

`factor → ( exp ) | number`的语法图：<img src="D:\Note\编译原理\Assets\语法图.png" style="zoom: 50%;" />

#### 2.重复和可选结构

1. **重复结构**：

   文法规则：`A → { B }`

   语法图：<img src="D:\Note\编译原理\Assets\重复结构语法图.png" style="zoom: 50%;" />

2. **可选结构**：

   文法规则：`A → [ B ]`

   语法图：<img src="D:\Note\编译原理\Assets\可选结构语法图.png" style="zoom:50%;" />

## 3.6 上下文无关语言的形式性质

#### 1.定义

**上下文无关文法**（Context-Free Grammar, **CFG**）由以下部分组成：

1. 一个终结符集合$T$
2. 一个非终结符集合$N$（与$T$不相交）
3. 一个产生式集合$P$，形如$A→a$，其中$A$是$N$ 中的元素，$a$是$(T∪N)^* $中的元素（可能是空序列）
4. 一个起始符号$S$，属于$N$

设$G$为上述定义的文法，即$ G=(T,N,P,S)$

在$G$上的推导步骤形式为$ αAγ⇒αβγ$，其中$α$和$γ$是$( T∪N )^*$中的元素，且$A→β $属于$P$

#### 2.符号集合

终结符和非终结符的并集$T∪N$

#### 3.句型

句型是$(T∪N)^* $中的字符串

#### 4.推导

将关系$ α⇒∗β $定义为推导步骤关系$ ⇒ $的传递闭包

也就是说，如果有零个或多个推导步骤，则有$ α⇒∗β（n≥0）$：
$$
α_1⇒α_2⇒⋯⇒α_{n−1}⇒α_n
$$
其中$α=α_1$，$β=α_n$（如果$N$=0，则$ α=β$）

在文法$G$上的推导形如$S⇒∗w$，且$w∈T∗$（即，$w$是终结符的一个串，称作句子），$S$是$G$的起始符号

#### 5.语言

由$G$生成的语言$ L(G) $定义为：
$$
L(G)=\{w∈T^* ∣存在推导 S⇒^* w 的 G\}
$$
即，$ L(G) $是从$S$ 可以推导出的所有句子的集合

#### 6.最左推导和最右推导

**最左推导**$S⇒∗w$是一个推导，其中每个推导步骤$ αAγ⇒αβγ$都满足$ α∈T∗$，即$α$仅由终结符组成

**最右推导**$S⇒∗w$是一个推导，其中每个推导步骤$ αAγ⇒αβγ$都满足$ γ∈T∗$，即$γ$仅由终结符组成

#### 7.分析树

文法$G$的分析树是一个带有标记的根树，具有以下性质：

1. 每个节点标记为一个终结符、非终结符或$ϵ$
2. 根节点标记为起始符号$S$
3. 每个叶节点标记为一个终结符或$ϵ$
4. 每个非叶节点标记为一个非终结符
5. 如果一个标记为$ A∈N $的节点有$N$个子节点，标记为 $X_1,X_2,…,X_n$（可以是终结符或非终结符），则 $A→X_1X_2…X_n∈P$

每个推导对应一个分析树

通常，许多推导可能对应同一个分析树

然而，每个分析树都有唯一的一个最左推导和一个最右推导

**最左推导**对应分析树的前序遍历

**最右推导**对应分析树的后序遍历的逆过程

#### 8.上下文无关语言

如果存在一个上下文无关文法$G$，使得$ L=L(G)$，则称字符串集合$ L $为上下文无关语言

#### 9.模糊文法

如果存在一个字符串$ w∈L(G)$，使得$ w $有两个不同的分析树（或最左推导或最右推导），则称文法$G$是**模糊**的

