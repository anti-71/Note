# 第六章 语义分析

## 准备阶段

### **一、语义分析阶段概述**

**核心目标（Purpose）**：计算编译过程中**上下文无关文法（context-free grammars）**和**标准解析算法**无法覆盖的**额外语义信息**（如类型关联、作用域规则等）

**静态语义分析（Static semantic analysis）**：程序执行前完成的语义检查 / 处理，典型任务包括：

- 构建符号表（symbol table）；
- 类型推断（type inference）；
- 类型检查（type checking）

### **二、语义分析的分类**

语义分析围绕两类需求展开：

1. **语言规则驱动的分析**：
   遵循编程语言的语法 / 语义规则，**验证程序正确性**（如变量未定义、操作符与操作数类型不匹配），保障程序可正确执行
2. **编译器优化驱动的分析**：
   编译器主动执行，**提升目标程序的运行效率**（如冗余计算消除、运算顺序优化）

### **三、静态语义分析的技术描述**

静态语义分析依赖两大核心技术：

1. **属性文法（Attribute grammar）**：

   定义：识别语言实体（变量、表达式等）的**属性**（如类型、作用域），通过**属性方程 / 语义规则**描述属性计算与语法规则的关联

   适用场景：对**语法导向语义（syntax-directed semantics）**语言（语义可通过语法结构推导），属性文法是天然适配工具

2. **抽象语法（Abstract syntax）**：
   通过**抽象语法树（AST）**提炼程序核心语法结构（忽略无关细节，聚焦语义表达）

### **四、静态语义分析的实现挑战**

与语法解析（Parsing）相比，静态语义分析的实现更复杂：

- **表达模糊性**：因编译流程中**分析时机（timing）**带来的关联问题（如跨作用域符号查询、延迟类型检查），难以像LL/LR算法一样形成清晰的形式化描述

- 流程差异：分为**多遍处理（Multi-pass，更常见）****和单遍处理（Single pass）**，两者执行逻辑完全不同：

  多遍：反复扫描中间表示，逐步完善语义信息；

  单遍：需实时关联语法单元的语义依赖（如边解析边检查类型）

## 6.1 属性与属性文法

### 一、属性

#### **1.属性（Attributes）的定义**

属性是**编程语言构造（如变量、表达式、过程等）的特性**，典型示例包括：

- 变量的数据类型（如 `int`、`float`）；
- 表达式的值（如 `1+2` 的结果）；
- 变量的内存位置（如栈帧偏移、全局存储地址）；
- 过程的目标代码（如编译生成的机器码）；
- 数字的有效位数（如 `3.14` 的有效位数为 3）

#### **2.属性的绑定（Binding）**

1. **绑定过程**：
   计算属性值，并将其与对应的**语言构造**（如变量、表达式）关联的过程

2. **绑定时间（Binding Time）**：
   属性绑定发生的时机（编译阶段或程序执行阶段）

3. **属性分类（按绑定时间）**：

   **静态属性（Static Attributes）**：执行**前**绑定（如编译阶段）；

   **动态属性（Dynamic Attributes）**：执行**时**绑定（如运行阶段）

#### **3.示例：属性的绑定时间与计算差异**

不同属性在**不同语言**中，绑定时间和计算方式差异显著：

| **属性类型**       | **示例场景**                         | **绑定时间 / 计算逻辑**                                      |
| ------------------ | ------------------------------------ | ------------------------------------------------------------ |
| **类型检查**       | C/Pascal vs LISP                     | - C/Pascal（静态类型）：编译时检查（**静态绑定**）； - LISP（动态类型）：运行时生成代码检查（**动态绑定**） |
| **表达式的值**     | 普通表达式 vs 常量表达式（如 `2+3`） | - 普通表达式（如 `a+b`）：运行时计算（**动态绑定**）； - 常量表达式：编译时计算（*常量折叠*，**静态绑定**） |
| **变量的内存分配** | FORTRAN77 vs LISP vs. C/Pascal       | - FORTRAN77：编译时分配（**静态绑定**）； - LISP：运行时分配（**动态绑定**）； - C/Pascal：混合模式（全局变量静态分配，局部变量动态分配） |
| **过程的目标代码** | 过程（如函数 `foo()`）               | 编译时由代码生成器生成（**静态绑定**）                       |
| **数字的有效位数** | 如 `3.14` 的有效位数                 | 编译阶段通常**不明确处理**（无显式绑定逻辑）                 |

### 二、属性文法（Attribute Grammars）

#### 1. 符号约定

- **$X.a$**：表示**文法符号$X$**关联的**属性$a$**的值（$X$为文法符号，$a$为其属性，如变量类型、表达式值等）

#### 2. 语法导向语义（Syntax-directed Semantics）

属性文法的核心思想是**“语义与语法结构直接关联”**：

- 每个文法符号（终结符 / 非终结符）绑定一组属性（如类型、值、作用域）；
- 对文法规则**$X₀ → X₁ X₂ … Xₙ$**（$X_0$为非终结符，$X₁…Xₙ$为文法符号），**符号$Xᵢ$的属性值（如 $Xᵢ.aⱼ$）** 与规则中 **其他符号的属性值** 存在依赖关系（通过语义规则描述）

#### 3. 属性文法的定义

属性文法是**属性方程（或语义规则）的集合**，针对语言的**所有文法规则**，形式为： 对文法规则**$X₀ → X₁ X₂ … Xₙ$** 及属性$a_1, a_2, ..., a_k$，存在方程：$\text{X}_i.\text{a}_j = f_{ij}\left( \text{X}_0.\text{a}_1, ..., \text{X}_0.\text{a}_k,\ \text{X}_1.\text{a}_1, ..., \text{X}_n.\text{a}_k \right)$

- **$f_{ij}$**：数学函数，定义属性$\text{X}_i.\text{a}_j$的计算逻辑，参数涵盖规则中**所有符号（$X₀$到$Xₙ$）的属性值**（体现属性依赖）

#### 4. 表示形式

属性文法通常以**表格形式**呈现，直观关联**文法规则**和**语义规则（属性方程）**：

| 文法规则（Grammar Rule） | 语义规则（Semantic Rules）                       |
| ------------------------ | ------------------------------------------------ |
| Rule 1                   | 关联的属性方程（Associated attribute equations） |
| ...                      | ...                                              |
| Rule n                   | 关联的属性方程（Associated attribute equations） |

### 三、属性文法的简化与扩展

#### **1.属性文法的元语言（Metalanguage）**

**定义**：属性文法中，**语义规则（属性方程）里允许使用的表达式集合**称为元语言

**能力限定**：

- 支持**算术运算**（+、-、×、÷ 等）、**逻辑运算**（与、或、非等）；
- 支持 **`if-then-else` 条件表达式**（用于错误处理，如检测非法输入）；
- 偶尔使用 **`case/switch` 分支**（处理多分支逻辑）

**作用**：元语言是编写语义规则的 “工具箱”，既保证规则的**形式化严谨性**，又允许灵活处理语义逻辑（如错误检测、复杂计算）

#### **2.元语言的扩展：引入函数**

元语言可扩展**自定义函数**，将重复逻辑封装为可复用的模块

- 示例：字符型数字转数值（如`'5'→5`）

  - 文法规则：`digit → D`（`D` 是字符型数字，如 `'0'~'9'`）

  - 语义规则：`digit.val = numval(D)`，其中`numval`是自定义函数：

    ```c
    int numval(char D) {  
        return (int)D - (int)'0'; // 字符转数值（如 '5' - '0' = 5）  
    }  
    ```

- **优势**：避免重复编写 “字符转数值” 的逻辑，提升规则的简洁性和可维护性

#### **3.属性文法的简化手段**

##### **（1）采用 “歧义文法”（Using ambiguous grammar）**

**背景**：此前的算术表达式文法通过**分层非终结符**（`Exp` 处理加减，`Term` 处理乘法）**消除歧义**，保证运算符优先级（乘法先于加减）

**简化思路**：直接使用 **更简洁的歧义文法**（如 `exp → exp + exp | exp * exp | (exp) | number`），**放弃语法层面的优先级控制**，仅通过**语义规则隐含优先级**（实际仍需结合解析顺序或额外处理，否则会导致歧义）

示例：

| 文法规则             | 语义规则                         |
| -------------------- | -------------------------------- |
| `exp₁ → exp₂ + exp₃` | `exp₁.val = exp₂.val + exp₃.val` |
| `exp₁ → exp₂ * exp₃` | `exp₁.val = exp₂.val × exp₃.val` |
| `exp₁ → (exp₂)`      | `exp₁.val = exp₂.val`            |
| `exp → number`       | `exp.val = number.val`           |

**缺陷**：文法本身存在歧义（如 `a + b * c` 可解析为 `(a+b)*c` 或 `a+(b*c)`），需通过**语法制导的优先级约定** 或编译器后续处理解决

##### **（2）用抽象语法树（AST）代替解析树（Parse Tree）**

两者对比：

- **解析树**：严格对应文法规则，包含所有非终结符（如 `Exp`、`Term`），结构冗余
- **AST**：仅保留**核心语法结构**（运算、操作数），省略中间非终结符，更简洁

示例：

```plaintext
      * (val=31×42=1302)  
     / \  
    -   42 (val=42)  
   / \  
 34   3  
(val=34) (val=3)  
```

**优势**：减少属性计算的节点数，提升分析效率；更贴合编译器实际实现（前端通常用 AST 做语义分析）

#### 4.语法树与属性文法的核心要点

**语法树的属性文法定义**

抽象语法树（AST）的结构可通过**属性文法**精确指定

**核心构造函数解析**

| **函数**        | **作用**                                                     |
| --------------- | ------------------------------------------------------------ |
| **`mkOpNode`**  | 构造**操作符节点**（非叶节点）： - 第 1 参数：操作符标签（如 `+`、`*`）； - 第 2、3 参数：左右子树（AST 节点） |
| **`mkNumNode`** | 构造**数字叶节点**： - 参数：数字的数值（如词法分析得到的 `number.lexval`） |

**属性文法的核心挑战**

设计属性文法时，需回答：

- **一致性**：属性的计算规则是否**无矛盾**（如同一属性不会被赋予多个不同值）？
- **完备性**：规则是否覆盖**所有语法结构**（无遗漏，如每个文法规则都对应语义规则）？

目前，**尚无通用方法证明属性文法的一致性和完备性**，需通过人工设计（如检查规则覆盖性、属性传递闭环）和测试保障

## 6.2 属性计算算法

### 准备阶段

#### 1.属性方程的本质与约束

属性方程的通用形式： $\text{X}_i.\text{a}_j = f_{ij}\left( \text{X}_0.\text{a}_1, \dots, \text{X}_n.\text{a}_k \right)$

- **语义**：左侧属性$\text{X}_i.\text{a}_j$的值，由右侧函数 $f_{ij}$ 计算，输入为其他属性（如 $\text{X}_0.\text{a}_1$、$\text{X}_n.\text{a}_k$ 等）
- **计算顺序约束**： 右侧属性（如 $\text{X}_0.\text{a}_1$）必须**先完成计算**，左侧属性（$\text{X}_i.\text{a}_j$）才能推导（否则函数 $f_{ij}$ 无有效输入）

#### 2.依赖图（Dependency Graphs）

为直观描述属性间的**依赖关系**，引入**有向图模型**：

- **节点**：每个属性（如 $\text{X}_i.\text{a}_j$）
- **边**：若属性$A$的计算依赖属性$B$，则添加**从$B$指向$A$的有向边**（表示$B$先计算，$A$后计算）

→ 依赖图是属性计算顺序的 “地图”，编译器需按边的方向规划计算流程

### 一、依赖图与计算顺序

#### 1. 依赖图的构造逻辑

**整体定义**： 一个字符串的**依赖图**，是其**解析树中所有非叶节点**对应的**文法规则依赖图的并集**

→ 解析树的每个内部节点（非叶子）对应一条文法规则，每条规则的局部依赖图被 “拼接” 为整体依赖图

**属性方程与边的关联**： 对属性方程$\text{X}_i.\text{a}_j = f_{ij}(\dots, \text{X}_m.\text{a}_k, \dots)$：

- 若$\text{X}_i.\text{a}_j$的计算依赖$\text{X}_m.\text{a}_k$，则在依赖图中添加**从 $\text{X}_m.\text{a}_k$到$\text{X}_i.\text{a}_j$的有向边**，表示前者是后者的计算前提

#### 2. 核心概念解析

**“字符串的依赖图”**： 针对具体输入（如表达式 `3+4`），其解析树的每个非叶节点（如 `exp→exp+term`）对应规则的依赖图，合并后构成该输入的完整依赖图

**“文法规则选择”**： 解析树的每个节点对应唯一文法规则（如 `exp` 可选 `exp+term` 或 `term`），不同规则会生成不同的局部依赖图

#### 3. 依赖图的作用：指导计算顺序

依赖图通过**有向边**显式约束属性计算顺序：

- 边$\text{X}_m.\text{a}_k \to \text{X}_i.\text{a}_j$表示：必须先计算$\text{X}_m.\text{a}_k$，再计算$\text{X}_i.\text{a}_j$
- 编译器可通过**拓扑排序**等算法，依据依赖图规划属性计算流程（确保依赖的属性先被求值）

#### 4.属性计算的拓扑排序与DAG约束

**核心逻辑**：属性计算的算法必须遵循**“依赖先算” 原则**：若属性$A$的计算依赖属性$B$（依赖图中存在边 `B→A`），则必须先计算$B$，再计算$A$

**关键概念**：

1. **拓扑排序（Topological Sort）**：
   满足 “依赖先算” 原则的**依赖图遍历顺序**

   即，遍历所有节点时，确保：若存在边 `B→A`，则$B$在遍历序列中出现在$A$之前

2. **有向无环图（DAG, Directed Acyclic Graph）**：
   依赖图必须是**无环的有向图**

   若依赖图存在环（如 `A→B` 且 `B→A`，形成循环依赖），则无法找到拓扑排序（循环依赖导致 “先算谁” 的矛盾），属性计算无法完成

**拓扑排序的多样性**：依赖图的拓扑排序不唯一

#### 5.**根节点的关键作用**：

**定义**：依赖图中**无入边的节点**（不依赖其他属性，是依赖链的起点）

**属性特征**：通常对应**词法单元（token）**的值（如数字 `3` 的 `val`、后缀 `o` 的 `base`），由词法分析阶段预先确定

**计算要求**：必须**优先计算**（因其他属性的依赖链始于此）

#### 6.属性计算的两类方法

##### （1）解析树方法（Parse Tree Method）

**原理**：编译时，针对**具体输入的解析树**动态构建依赖图，再通过拓扑排序确定属性计算顺序

**优缺点**：

- **灵活性高**：适配任意语法结构（无论输入如何复杂）
- **复杂度高**：每次编译需重新构建依赖图，还需检测循环依赖（判断是否为DAG）

##### （2）基于规则的方法（Rule-Based Method）

**原理**：编译器构建阶段（而非编译时），**预先固定属性计算顺序**（如根据文法规则的层次，设定 “先算叶节点，再算父节点”）

**优缺点**：

- **效率高**：无需动态构建依赖图，直接按预设顺序计算
- **灵活性低**：依赖文法规则的稳定性（若文法变更，需重新调整计算顺序）

### 二、综合属性（Synthesized Attributes）

#### 1.定义

**定义核心**： 综合属性的**依赖关系方向是 “子→父”**（在解析树中，父节点的属性依赖子节点的属性）

**形式化描述**： 对文法规则$A \to X_1 X_2 \dots X_n$（$A$是父节点，$X_1 \dots X_n$是子节点），若属性$A.a$的方程满足：$A.a = f\left( X_1.a_1, \dots, X_1.a_k,\ \dots,\ X_n.a_1, \dots, X_n.a_k \right)$ （仅依赖**子节点的属性**，不依赖父节点或其他兄弟节点的属性），则 $A.a$ 是**综合属性**

#### 2.S - 属性文法（S-attributed Grammar）

若一个属性文法中**所有属性都是综合属性**，则称为 **S - 属性文法**

#### 3.计算方法：后序遍历（自底向上）

**核心逻辑**： 综合属性依赖**子节点的属性**，因此必须**先计算子节点，再计算父节点**（自底向上的顺序）

**算法示例（后序遍历过程 `PostEval`）**：

```plaintext
Procedure PostEval(T: treenode);  // T 是解析树/语法树的节点  
Begin  
  For each child C of T do        // 第一步：递归遍历所有子节点  
    PostEval(C);                  // 确保子节点的属性已计算完成  
  Compute all synthesized attributes of T;  // 第二步：计算当前节点的综合属性  
End  
```

- **示例场景**：解析数字 `345` 时，先计算叶子节点 `digit(3).val`、`digit(4).val`、`digit(5).val`，再递归计算父节点 `num(3).val`、`num(34).val`、`num(345).val`—— 完全符合后序遍历的顺序

### 三、继承属性（Inherited Attributes）

#### 1.定义与示例

**定义**：不满足 “综合属性（子→父依赖）” 的属性，称为**继承属性**

#### 2.继承属性的依赖模式

继承属性的依赖方向突破 “子→父” 限制，核心模式：

##### （1）父→子继承

**逻辑**：父节点的属性（如 `var-list.dtype`）传递给子节点（如 `id.dtype`、`var-list₂.dtype`）

**场景**：变量声明中，类型从父 `var-list` 批量传递给子 `id` 和嵌套的 `var-list`

##### （2）兄弟→兄弟继承

**逻辑**：同一父节点下，**前序兄弟的属性**传递给**后序兄弟**（如 `id₁.dtype` → `var-list₂.dtype` → `id₂.dtype`）

**优化**：若语法树用**兄弟指针**连接，依赖可沿兄弟链直接传递，减少冗余结构

#### 3.计算方法：前序遍历（Preorder Traversal）

继承属性依赖**父节点或前序兄弟的属性**，需**先算依赖方，再算子节点**，对应**前序遍历**（或前序 + 中序组合）

##### 伪代码实现（`PreEval` 过程）：

```plaintext
Procedure PreEval(T: treenode);  // T 是解析树/语法树节点  
Begin  
  For each child C of T do:  
    // 第一步：计算子节点 C 的继承属性（依赖 T 或前序兄弟的已计算值）  
    Compute all inherited attributes of C;  
    // 第二步：递归遍历子节点 C（保证子节点内部属性计算）  
    PreEval(C);  
End  
```

### 四、扩展：**属性计算的两阶段遍历（解决依赖顺序冲突）**

#### **核心问题**：

Example 6.14中，属性间存在 **依赖顺序冲突**：

- `isFloat`（综合属性）需**后序计算**（子→父，如 `exp/exp` 的 `isFloat` 依赖子节点）；
- `etype`（继承属性）需**前序传递**（父→子，如 `exp/exp` 中父节点的 `etype` 传递给子节点）；
- `val`（综合属性）需**后序计算**（依赖 `etype` 和子节点的 `val`）

单次遍历无法同时满足 “后序算综合” 和 “前序传继承”，因此需要**两次遍历**拆分依赖

#### **阶段 1：第一遍（后序遍历）—— 计算综合属性 `isFloat`**

**目标**：确定每个表达式节点是否含浮点部分（为第二遍的 `etype` 提供依据）

**遍历方式**：后序遍历（子→父）

**处理逻辑**：

- 对 `num` 节点：`isFloat = false`；
- 对 `num.num` 节点：`isFloat = true`；
- 对 `exp/exp` 节点：`isFloat = 左子.isFloat ∨ 右子.isFloat`（子节点先算，父节点后算，符合后序）

#### **阶段 2：第二遍（混合遍历：前序 + 后序）—— 计算继承属性 `etype` 和综合属性 `val`**

**目标**：

- 前序传递 `etype`（根据根节点的 `isFloat` 确定全局类型：`isFloat=true→float`，否则 `int`）；
- 后序计算 `val`（根据 `etype` 选择运算：整数整除 `div` 或浮点除法 `/`）

**遍历逻辑**：

1. **前序传递 `etype`**：从根节点（`S`）开始，将 `etype` 传递给子节点（如 `exp/exp` 中，父节点的 `etype` 传递给左右子节点）
2. **后序计算 `val`**：子节点的 `val` 计算完成后，父节点根据 `etype` 合成 `val`（如 `exp/exp` 的 `val` 依赖左右子节点的 `val` 和 `etype`）

### 五、属性作为参数与返回值

#### 1.核心动机：属性的 “临时化” 与存储优化

许多属性（如继承属性 `base`、中间计算的临时值）仅用于**推导其他属性**，无需长期存储在语法树的节点结构体中

通过**函数参数（传递继承属性）和返回值（传递综合属性）**，可动态处理这些属性，避免冗余存储

#### 2.继承属性：作为函数参数（前序传递）

**计算逻辑**：继承属性依赖**父→子 / 兄弟→兄弟**的传递，对应**前序遍历**（先处理父 / 前序节点，再处理子 / 后序节点）

**实现方式**：将继承属性作为**函数调用的参数**，在递归处理子节点时传递

- **示例关联**：
  `EvalNum(T, base)` 中，`base` 是继承属性（来自父节点），通过参数传递给子节点的计算函数，确保前序依赖被满足

#### 3.综合属性：作为函数返回值（后序合成）

**计算逻辑**：综合属性依赖 **子→父** 的合成（如 `val` 由子节点的 `val` 合成），对应**后序遍历**（先处理子节点，再处理父节点）

**实现方式**：将综合属性作为**函数调用的返回值**，子节点计算完成后，父节点根据返回值合成自身属性

- **示例关联**：
  `EvalBase` 返回基数（`8` 或 `10`），`EvalNum` 返回数值（如 `345o` 的 `229`），父节点通过返回值递归合成结果

### 六、用外部数据结构存储属性值

#### **1.为什么需要外部数据结构？**

之前学的**参数 / 返回值**和**语法树节点存储**有局限：

- **参数 / 返回值**：适合**临时、简单**的属性但如果属性**结构复杂**（比如类型包含多个字段）、**需要频繁访问**（翻译过程中到处要用），传参数会很麻烦
- **语法树节点存储**：如果属性太多 / 太复杂，会让节点结构体臃肿；而且有些属性（比如变量的作用域）和语法树结构关联弱，存节点里不合理

#### **2.适用场景**

当属性满足以下条件时，适合用外部数据结构：

1. **结构复杂**：属性不是简单整数 / 布尔值，而是包含多个字段（如类型 `{int, float, array(int[10])}`）
2. **访问频繁**：翻译过程中**任意阶段都可能需要访问**（比如类型检查、代码生成都要查变量类型）
3. **共享性强**：属性需要在不同节点、不同阶段共享（如符号的作用域，多个节点可能引用同一变量）

#### **3.实现方法**

##### **（1）存储：用外部结构承载属性**

选择**表（Table）、图（Graph）**等数据结构，把属性和语法树节点解耦存储

- **典型例子：符号表（Symbol Table）**：
  以**标识符（如`x`、`y`）** 为键，存储其**类型（int/float）、作用域、内存地址**等属性

  语法树节点只需存标识符名称，属性都存在符号表里

##### **（2）计算：用过程调用替代属性方程**

原来的 “属性方程”（如 `A.val = B.val + C.val`），换成**对外部结构的操作**（如查符号表、更新符号表）

- 示例（变量声明`float x`）：
  - 语法树节点是 `id(x)`，但 `x` 的类型 `float` 存在符号表
  - 翻译时，遇到 `x` 就调用 `lookup_type("x")` 查类型，遇到赋值就调用 `update_address("x", 0x100)` 更新内存地址

#### **4.符号表的实际作用**

1. **词法 / 语法分析阶段**：遇到变量声明（如 `float x`），调用 `insert_symbol("x", "float")`，把 `x` 的类型存到符号表
2. **语义分析阶段**：遇到 `x = 5`，调用 `lookup_type("x")` 检查类型是否匹配（`float` 能否存整数 `5`）
3. **代码生成阶段**：遇到 `x`，调用 `lookup_address("x")` 获取内存地址，生成加载指令

### 七、解析过程中属性的计算（Attribute Computation During Parsing）

#### **1.基本前提：解析方法与属性计算的关联**

解析阶段能否成功计算属性，取决于所采用解析方法（如 LL、LR）的能力和特性：

- 主流解析方法（LL、LR）均**从左到右处理输入**，要求属性可通过**语法树的左到右遍历**计算（**综合属性（Synthesized Attributes）天然满足**，因其依赖子节点，归约时可自然计算）

#### **2.L - 属性文法（L-attributed Grammar）定义**

对于属性集$a_1, ..., a_k$，若文法满足：

- 对**每个继承属性$a_j$**和**每条产生式 $X_0 \to X_1 X_2 ... X_n$**，
- $X_i$的$a_j$的计算式仅依赖：
  - 父节点$X_0$的属性（$X_0.a_1, ..., X_0.a_k$），
  - 以及$X_i$左侧符号（$X_1, ..., X_{i-1}$）的属性（$X_1.a_1, ..., X_{i-1}.a_k$）

简言之：**继承属性的计算只能依赖 “左侧已处理符号” 的属性**

- **S - 属性文法是 L - 属性文法的特例**（仅含综合属性，依赖子节点，天然符合左到右遍历）

#### **3.解析器对属性的处理能力**

| 解析方式                 | 处理能力                                                     |
| ------------------------ | ------------------------------------------------------------ |
| **自顶向下（递归下降）** | 可处理 L - 属性文法： - 继承属性 → 作为函数参数传递， - 综合属性 → 作为函数返回值 |
| **自底向上（LR）**       | 擅长处理**综合属性**，但**继承属性难以直接处理**（需特殊技巧） |

#### **4.LR解析中处理属性的具体方法**

##### **(1) 综合属性的计算（以表达式求值为例）**

**值栈（Value Stack）**：与解析栈并行维护，存储综合属性值

**过程**：归约时，根据产生式的语义规则计算父节点的综合属性

示例：表达式 `3*4+5` 的解析与求值：

- 归约 `E→n` 时，`E.val = n.val`（如 `3` 归约为 `E`，值栈存 `3`）；
- 归约 `E→E*E` 时，`E1.val = E2.val * E3.val`（如 `3*4` 归约为 `E`，值栈存 `12`）；
- 最终归约 `E→E+E` 时，`E1.val = 12 + 5 = 17`

##### **(2) 继承属性的计算（利用已计算的综合属性）**

当继承属性依赖**左侧符号的综合属性**时（如产生式 `A→B C`，`C.i = f(B.s)`，其中 `B.s` 是$B$的综合属性），可通过以下方式处理：

###### **方法 1：插入 ε 产生式**

通过插入空产生式（如 `A→B C D`，`D→ε`），在$B$归约后保存其综合属性，供$C$的继承属性使用：

**语义规则**：

- $B$归约时，计算 `B.s` 并保存到 `saved_i`；
- $C$归约时，`C.i = saved_i`（利用已保存的$B$的综合属性）

###### **方法 2：直接访问值栈（位置可预测时）**

若值栈中属性的位置可通过文法预测，则无需 ε 产生式

示例：声明语句的类型继承（ `decl→type var-list` ，`var-list.dtype` 继承 `type.dtype`）：

- 产生式 `var-list1→id, var-list2` 中，`id` 的类型需从左侧的 `type` 获取，值栈中 `type.dtype` 的位置可预测（如 `valstack[top-3]` 或 `valstack[top-1]`），直接访问该位置取值

#### **5.直接访问值栈的问题与解决方案**

**问题**：

1. **安全性低**：自动生成的解析器中，直接访问值栈易出错；
2. **局限性**：仅当属性在值栈中的位置可通过文法严格预测时有效

**更优方案**： 采用**外部数据结构（如符号表）存储继承属性**，结合 ε 产生式传递值（虽可能引入解析冲突，但可控）

### 八、属性计算对语法的依赖

#### **1.核心定理（Knuth, 1968）**

给定**任意属性文法**，可通过**合理修改文法结构**，将所有**继承属性（Inherited Attributes）转换为综合属性（Synthesized Attributes）**，且**不改变文法所定义的语言**（即生成的句子集合保持不变）

#### 2.定理解读

**属性类型的本质差异**：

- 综合属性：依赖**子节点**的属性（归约时自然计算，LR解析友好）
- 继承属性：依赖**父节点或左侧兄弟节点**的属性（需额外处理，如L - 属性文法约束）

**文法修改的核心思路**：通过**引入辅助非终结符**或**调整产生式结构**，将原本 “上层→下层” 的继承依赖，转化为 “下层→上层” 的综合依赖例如：

- 若原产生式 `A→B` 中 `B.i` 继承 `A.a`，可改写为 `A→C B`，让 `C` 先捕获 `A.a` 并以综合属性传递给 `B`，间接模拟继承效果

**理论意义**：该定理证明：**继承属性的处理复杂度可通过文法变换降低**（因综合属性在LR等解析器中更易实现），为语义分析的工程化提供理论支撑——即使文法含继承属性，也可通过改写文法，用更简单的综合属性方式处理