# 网络编程

**网络编程**

可以让设备中的程序与网络上其他设备中的程序进行数据交互的技术（实现网络通信）

**基本的通信架构**

基本的通信架构有2种形式：CS架构（Client客户端/Server服务端）、BS架构（Browseri浏览器/Server服务端）

Client-Server（Cs）架构：

Client（客户端）

需要程序员开发客户端软件

需要用户下载安装客户端软件

Server（服务端）

需要程序员开发服务端程序

Browser-Server（BS）架构：

Browser（浏览器）

不需要程序员开发

需要用户下载安装浏览器

Server（服务端）

需要程序员开发服务端程序

**Java提供了哪些网络编程解决方案？**

java.net.*包下提供了网络编程的解决方案！

## 第一节 网络编程三要素

**IP地址**：设备在网络中的地址，是设备在网络中的唯一标识

**端口**：应用程序在设备中的唯一标识

**协议**：连接和数据在网络中传输的规则

### 1.IP地址

- IP（Internet Protocol）：全称”互联网协议地址”，是分配给上网设备的唯一标识
- 目前，被广泛采用的IP地址形式有两种：IPV4、IPV6

**IPV4**

IPv4是Internet Protocol version 4的缩写，它使用32位地址，通常以**点分十进制**表示

**IPv6**

IPv6是Internet Protocol version 6的缩写，它使用128位地址，号称可以为地球上的每一粒沙子编号

IPv6分成8段，每段每四位编码成一个十六进制位表示，每段之间用冒号（：）分开，将这种方式称为**冒分十六进制**

**IP域名（Domain Name）**

用于在互联网上识别和定位网站的**人类可读的名称**

**DNS域名解析（Domain Name System）**

是互联网中用于将域名转换为对应P地址的分布式命名系统。它充当互联网的“电话簿”，将易记的域名映射到数字化的IP地址，使得用户可以通过域名来访问网站和其他网络资源

**公网IP、内网IP**

- 公网IP：是可以连接到互联网的IP地址
- 内网IP：也叫局域网IP,是只能组织机构内部使用的IP地址；例如，192.168. 开头的就是常见的局域网地址，范围为192.168.0.0——192.168.255.255,专门为组织机构内部使用

**本机IP**

127.0.0.1、localhost：代表本机IP,只会寻找当前程序所在的主机

**IP常用命令**

- ipconfig：查看本机lP地址
- ping IP地址：检查网络是否连通

**InetAddress**

代表IP地址

**InetAddress的常用方法**

| InetAddress类的常用方法                                      | 说明                                           |
| ------------------------------------------------------------ | ---------------------------------------------- |
| `public static InetAddress getLocalHost() throws UnknownHostException` | 获取本机IP，返回一个InetAddress对象            |
| `public String getHostName()`                                | 获取该ip地址对象对应的主机名                   |
| `public String getHostAddress()`                             | 获取该ip地址对象中的ip地址信息                 |
| `public static InetAddress getByName(String host) throws UnknownHostException` | 根据ip地址或者域名，返回一个InetAddress对象    |
| `public boolean isReachable(int timeout) throws IOException` | 判断主机在指定毫秒内与该ip对应的主机是否能连通 |

**代码**

```java
// 目标：认识InetAddress获取本机IP对象和对方IP对象
        try {
            // 1、获取本机IP对象
            InetAddress ip1 = InetAddress.getLocalHost();
            System.out.println(ip1.getHostName());
            System.out.println(ip1.getHostAddress());

            // 2、获取对方IP对象
            InetAddress ip2 = InetAddress.getByName("www.baidu.com");
            System.out.println(ip2.getHostName());
            System.out.println(ip2.getHostAddress());

            // 判断主机与对方主机是否互通
            System.out.println(ip2.isReachable(5000));
        } catch (Exception e) {
            e.printStackTrace();
        }
```

### 2.端口

用来标记标记正在计算机设备上运行的应用程序，被规定为一个16位的二进制，范围是0~65535

**端口分类**

- 周知端口：0~1023，被预先定义的知名应用占用（如：HTTP占用80,FTP占用21）
- 注册端口：1024~49151，分配给用户进程或某些应用程序
- 动态端口：49152到65535，之所以称为动态端口，是因为它一般不固定分配某种进程，而是动态分配

注意：我们自己开发的程序一般选择使用注册端口，且一个设备中不能出现两个程序的端口号一样，否则报错

### 3.协议

网络上通信的设备，事先规定的连接规则，以及传输数据的规则被称为网络通信协议

**开放式网络互联标准：0SI网络参考模型**

- OS工网络参考模型：全球网络互联标准
- TCP/IP网络模型：事实上的国际标准

| OSI网络参考模型 | TCP/IP网络模型    | 各层对应           | 面向操作                                                 |
| --------------- | ----------------- | ------------------ | -------------------------------------------------------- |
| 应用层          | 应用层            | HTTP、FTP、SMTP... | 应用程序需要关注的：浏览器，邮箱。程序员一般在这一层开发 |
| 表示层          |                   |                    |                                                          |
| 会话层          |                   |                    |                                                          |
| 传输层          | 传输层            | UDP、TCP...        | 选择使用的TCP，UDP协议                                   |
| 网络层          | 网络层            | IP...              | 封装源和目标IP                                           |
| 数据链路层      | 数据链路层+物理层 | 比特流...          | 物理设备中传输（电缆、光纤、无线等）                     |
| 物理层          |                   |                    |                                                          |

**传输层的2个通信协议**

UDP（User Datagram Protocol）：用户数据报协议

TCP（Transmission Control Protocol）：传输控制协议

**UDP协议**

特点：无连接、不可靠通信

不事先建立连接，数据按照包发，一包数据包含：自己的1P、端口、目的地P、端口和数据（限制在64KB内）等

发送方不管对方是否在线，数据在中间丢失也不管，如果接收方收到数据也不返回确认，故是不可靠的

**TCP协议**

特点：面向连接、可靠通信

TCP的最终目的：要保证在不可靠的信道上实现可靠的数据传输

TCP主要有三个步骤实现可靠传输：**三次握手**建立连接，传输数据进行确认，**四次挥手**断开连接

## 第二节 UDP通信

### 1.快速入门

**UDP通信的实现**

Java提供了一个java.net.DatagramSocket类来实现UDP通信

DatagramSocket：用于创建客户端、服务端

| 构造器                            | 说明                                             |
| --------------------------------- | ------------------------------------------------ |
| `public DatagramSocket()`         | 创建客户端的Socket对象，系统会随机分配一个端口号 |
| `public DatagramSocket(int port)` | 创建服务端的Socket对象，并指定端口号             |

| 方法                                    | 说明               |
| --------------------------------------- | ------------------ |
| `public void send(DatagramPacket dp)`   | 发送数据包         |
| `public void receive(DatagramPacket p)` | 使用数据包接收数据 |

DatagramPacket：创建数据包

| 构造器                                                       | 说明                     |
| ------------------------------------------------------------ | ------------------------ |
| `public DatagramPacket(byte[] buf, int length, InetAddress address, int port)` | 创建发出去的数据包对象   |
| `public DatagramPacket(byte[] buf, int length)`              | 创建用来接收数据的数据包 |

| 方法                     | 说明                           |
| ------------------------ | ------------------------------ |
| `public int getLength()` | 获取数据包实际接收到的字节个数 |

**代码**

`UDPClientDemo1`

```java
System.out.println("===客户端启动了===");
        // 目标：完成UDP通信一发一收：客户端开发
        // 1、创建发送端对象（代表抛韭菜的人）
        DatagramSocket socket = new DatagramSocket(); // 随机端口
        // 2、创建数据包对象封装要发送的数据（韭菜盘子）
        byte[] bytes = "我是客户端，约你今晚啤酒、龙虾、小烧烤".getBytes();
        /**
         * 参数一：发送的数据，字节数组（韭菜）
         * 参数二：发送的字节长度
         * 参数三：目的地的IP地址
         * 参数四：服务端程序的端口号
         */
        DatagramPacket packet = new DatagramPacket(bytes, bytes.length, InetAddress.getLocalHost(), 8080);

        // 3.让发送端对象发送数据包的数据
        socket.send(packet);
```

`UDPServerDemo2`

```java
System.out.println("===服务端启动了===");
        // 目标：完成UDP通信一发一收：服务端开发
        // 创建接收端对象，注册端口（接韭菜的人）
        DatagramSocket socket = new DatagramSocket(8080);

        // 2、创建一个数据包对象负责接收数据（韭菜盘子）
        byte[] buf = new byte[1024 * 64];
        DatagramPacket packet = new DatagramPacket(buf, buf.length);

        // 3、接收数据，将数据对象封装到数据包对象的字节数组中去
        socket.receive(packet);

        // 4、看看数据是否收到了
        int len = packet.getLength(); // 获取当前收到的数据长度
        String data = new String(buf, 0, len);
        System.out.println("服务端收到了：" + data);

        // 获取对方的ip对象
        String ip = packet.getAddress().getHostAddress();
        int port = packet.getPort();
        System.out.println("对方IP：" + ip + " 对方端口：" + port);
```

### 2.多发多收

**客户端实现步骤**

1. 创建DatagramSocketi对象（发送端对象
2. 使用while死循环不断的接收用户的数据输入，如果用户输入的exit则退出程序
3. 如果用户输入的不是exit,把数据封装成DatagramPacket
4. 使用DatagramSocket对象的send方法将数据包对象进行发送
5. 释放资源

**接收端实现步骤**

1. 创建DatagramSocketi对象并指定端口（接收端对象）
2. 创建DatagramPacket对象接收数据（数据包对象）
3. 使用DatagramSocket对象的receive方法传入DatagramPacket对象
4. 使用while死循环不断的进行第3步

**代码**

`UDPClientDemo1`

```java
System.out.println("===客户端启动了===");
        // 目标：完成UDP通信多发多收：客户端开发
        // 1、创建发送端对象（代表抛韭菜的人）
        DatagramSocket socket = new DatagramSocket(); // 随机端口

        Scanner sc = new Scanner(System.in);
        while (true) {
            // 2、创建数据包对象封装要发送的数据（韭菜盘子）
            System.out.println("请输入要发送的内容：");
            String msg = sc.nextLine();

            // 如果用戶輸入的是exit，则退出
            if ("exit".equals(msg)) {
                System.out.println("===客户端退出===");
                socket.close();
                break;
            }

            byte[] bytes = msg.getBytes();
            DatagramPacket packet = new DatagramPacket(bytes, bytes.length, InetAddress.getLocalHost(), 8080);

            // 3.让发送端对象发送数据包的数据
            socket.send(packet);
        }
```

`UDPServverDemo2`

```java
System.out.println("===服务端启动了===");
        // 目标：完成UDP通信多发多收：服务端开发
        // 创建接收端对象，注册端口（接韭菜的人）
        DatagramSocket socket = new DatagramSocket(8080);

        // 2、创建一个数据包对象负责接收数据（韭菜盘子）
        byte[] buf = new byte[1024 * 64];
        DatagramPacket packet = new DatagramPacket(buf, buf.length);

        while (true) {
            // 3、接收数据，将数据对象封装到数据包对象的字节数组中去
            socket.receive(packet); // 等待式接收数据

            // 4、看看数据是否收到了
            int len = packet.getLength(); // 获取当前收到的数据长度
            String data = new String(buf, 0, len);
            System.out.println("服务端收到了：" + data);

            // 获取对方的ip对象
            String ip = packet.getAddress().getHostAddress();
            int port = packet.getPort();
            System.out.println("对方IP：" + ip + " 对方端口：" + port);

            System.out.println("-----------------------------------------");
        }
```

## 第三节 TCP通信

### 1.快速入门

**TCP通信的实现一发一收-客户端开发**

客户端程序就是通过java.net包下的Socket类来实现的

| 构造器                                 | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| `public Socket(String host, int port)` | 根据指定的服务器ID、端口号请求与服务端建立连接，连接通过后获得客户端Socket |

| 方法                                    | 说明               |
| --------------------------------------- | ------------------ |
| `public OutputStream getOutputStream()` | 获得字节输出流对象 |
| `public InputStream getInputStream()`   | 获得字节输入流对象 |

1. 创建客户端的Socket对象，请求与服务端的连接
2. 使用socket对象调用getoutputstream()方法得到字节输出流
3. 使用字节输出流完成数据的发送
4. 释放资源：关闭socket管道

**代码**

```java
// 目标：实现TCP通信下一发一收：客户端开发
        // 1、创建Socket管道对象，请求与服务端的Socket链接。可靠链接
        try {
            Socket socket = new Socket("127.0.0.1",9999);

            // 2、从socket通信管道中得到一个字节输出流
            OutputStream os = socket.getOutputStream();

            // 3、特殊数据流
            DataOutputStream dos =  new DataOutputStream(os);
            dos.writeInt(1);
            dos.writeUTF("我想你了，你在哪儿？");

            // 4、关闭资源
            socket.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
```

**TCP通信的实现一发一收-服务端开发**

服务端是通过java.net包下的ServerSocket类来实现的

| 构造器                          | 说明                 |
| ------------------------------- | -------------------- |
| `public ServerSocket(int port)` | 为服务端程序注册端口 |

| 方法                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `public Socket accept()` | 阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的 Socket 对象 |

**代码**

```java
// 目标：实现TCP通信下一发一收：服务端开发
        System.out.println("服务端启动了...");
        // 1、创建服务端ServerSocket对象，绑定端口号，监听客户端连接
        ServerSocket ss = new ServerSocket(9999);
        // 2、调用accept方法，阻塞等待客户端连接，一旦有客户端链接会返回一个Socket对象
        Socket socket = ss.accept();
        // 3、获取输入流，读取客户端发送的数据
        InputStream is = socket.getInputStream();
        // 4、把字节输入流包装成特殊数据输入流
        DataInputStream dis  = new DataInputStream(is);
        // 5、读取数据
        int id = dis.readInt();
        String msg = dis.readUTF();
        System.out.println("id=" + id + ", 收到的客户端msg=" + msg);
        // 6、客户端的ip和端口（谁给我发的）
        System.out.println("客户端的ip=" + socket.getInetAddress().getHostAddress());
        System.out.println("客户端的端口=" + socket.getPort());
```

### 2.多发多收

1. 客户端使用死循环，让用户不断输入消息
2. 服务端也使用死循环，控制服务端程序收完消息后，继续去接收下一个消息

**代码**

`ClientDeni1`

```java
// 目标：实现TCP通信下多发多收：客户端开发
        System.out.println("客户端启动...");
        // 1、创建Socket管道对象，请求与服务端的Socket链接。可靠链接
        try {
            Socket socket = new Socket("127.0.0.1",9999);

            // 2、从socket通信管道中得到一个字节输出流
            OutputStream os = socket.getOutputStream();

            // 3、特殊数据流
            DataOutputStream dos =  new DataOutputStream(os);

            Scanner sc = new Scanner(System.in);
            while (true) {
                System.out.println("请输入：");
                String msg = sc.nextLine();
                if ("exit".equals(msg)) {
                    System.out.println("退出成功！");
                    socket.close(); // 关闭socket
                    break;
                }

                dos.writeUTF(msg); // 发送数据
                dos.flush();
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
```

`ServerDemo2`

```java
// 目标：实现TCP通信下多发多收：服务端开发
        System.out.println("服务端启动了...");
        // 1、创建服务端ServerSocket对象，绑定端口号，监听客户端连接
        ServerSocket ss = new ServerSocket(9999);
        // 2、调用accept方法，阻塞等待客户端连接，一旦有客户端链接会返回一个Socket对象
        Socket socket = ss.accept();
        // 3、获取输入流，读取客户端发送的数据
        InputStream is = socket.getInputStream();
        // 4、把字节输入流包装成特殊数据输入流
        DataInputStream dis  = new DataInputStream(is);
        while (true) {
            // 5、读取数据
            String msg = dis.readUTF(); // 等待读取客户端发送的数据
            System.out.println("收到的客户端msg=" + msg);
            // 6、客户端的ip和端口（谁给我发的）
            System.out.println("客户端的ip=" + socket.getInetAddress().getHostAddress());
            System.out.println("客户端的端口=" + socket.getPort());
            System.out.println("---------------------------------------------------------");
        }
```

### 3.同时接收多个客户端的消息

**目前我们开发的服务端程序，是否可以支持同时与多个客户端通信？**

不可以，因为服务端现在只有一个主线程，只能处理一个客户端的消息

**如何实现？**

主线程负责客户端连接，每收到一个socket，就创建一个线程处理接收信息

**代码**

`ClientDemo1`

```java
// 目标：实现TCP通信下多发多收：支持多个客户端开发
        System.out.println("客户端启动...");
        // 1、创建Socket管道对象，请求与服务端的Socket链接。可靠链接
        try {
            Socket socket = new Socket("127.0.0.1",9999);

            // 2、从socket通信管道中得到一个字节输出流
            OutputStream os = socket.getOutputStream();

            // 3、特殊数据流
            DataOutputStream dos =  new DataOutputStream(os);

            Scanner sc = new Scanner(System.in);
            while (true) {
                System.out.println("请输入：");
                String msg = sc.nextLine();
                if ("exit".equals(msg)) {
                    System.out.println("退出成功！");
                    socket.close(); // 关闭socket
                    break;
                }

                dos.writeUTF(msg); // 发送数据
                dos.flush();
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
```

`ServerDemo2`

```java
// 目标：实现TCP通信下多发多收：服务端开发，支持多个客户端开发
        System.out.println("服务端启动了...");
        // 1、创建服务端ServerSocket对象，绑定端口号，监听客户端连接
        ServerSocket ss = new ServerSocket(9999);
        while (true) {
            // 2、调用accept方法，阻塞等待客户端连接，一旦有客户端链接会返回一个Socket对象
            Socket socket = ss.accept();
            System.out.println("一个客户端上线了..." + socket.getInetAddress().getHostAddress());
            // 3、把这个客户端管道交给一个独立的子线程专门负责接收这个管道的消息
            new ServerReader(socket).start();
        }
```

`ServerReader`

```java
public class ServerReader extends Thread{
    private Socket socket;
    public ServerReader(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            // 读取管道消息
            // 3、获取输入流，读取客户端发送的数据
            InputStream is = socket.getInputStream();
            // 4、把字节输入流包装成特殊数据输入流
            DataInputStream dis  = new DataInputStream(is);
            while (true) {
                // 5、读取数据
                String msg = dis.readUTF(); // 等待读取客户端发送的数据
                System.out.println("收到的客户端msg=" + msg);
                // 6、客户端的ip和端口（谁给我发的）
                System.out.println("客户端的ip=" + socket.getInetAddress().getHostAddress());
                System.out.println("客户端的端口=" + socket.getPort());
                System.out.println("---------------------------------------------------------");
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("客户端断开了");
        }
    }
}

```

### 4.其他应用：B/S架构的原理

主线程：负责接收浏览器连接，每接收到一个socket，就创建一个子线程负责接收信息，响应一个网页

注意：服务器必须给浏览器响应HTTP协议规定的数据格式，否则浏览器不识别返回的数据

HTTP协议规定：响应给浏览器的数据格式必须满足如下格式

<img src="D:\Note\Java\Assets\HTTP协议.png" style="zoom: 50%;" />

**代码**

`ServerDemo`

```java
 // 目标：BS架构的原理理解
        System.out.println("服务端启动了...");
        // 1、创建服务端ServerSocket对象，绑定端口号，监听客户端连接
        ServerSocket ss = new ServerSocket(8080);
        while (true) {
            // 2、调用accept方法，阻塞等待客户端连接，一旦有客户端链接会返回一个Socket对象
            Socket socket = ss.accept();
            System.out.println("一个客户端上线了..." + socket.getInetAddress().getHostAddress());
            // 3、把这个客户端管道交给一个独立的子线程专门负责接收这个管道的消息
            new ServerReader(socket).start();
        } // 目标：BS架构的原理理解
        System.out.println("服务端启动了...");
        // 1、创建服务端ServerSocket对象，绑定端口号，监听客户端连接
        ServerSocket ss = new ServerSocket(8080);
        while (true) {
            // 2、调用accept方法，阻塞等待客户端连接，一旦有客户端链接会返回一个Socket对象
            Socket socket = ss.accept();
            System.out.println("一个客户端上线了..." + socket.getInetAddress().getHostAddress());
            // 3、把这个客户端管道交给一个独立的子线程专门负责接收这个管道的消息
            new ServerReader(socket).start();
        }
```

`ServerReader`

```java
public class ServerReader extends Thread{
    private Socket socket;
    public ServerReader(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            // 给当前对应的浏览器管道响应一个网页数据回去
            OutputStream os =  socket.getOutputStream();
            // 通过字节输出流包装写出去数据给浏览器
            // 把字节输出流包装成打印流
            PrintStream ps = new PrintStream(os);
            // 写网页数据回去
            ps.println("HTTP/1.1 200 OK");
            ps.println("Content-Type:text/html;charset=utf-8");
            ps.println(); // 必须要换一行
            ps.println("<html>");
            ps.println("<head>");
            ps.println("<meta charset=utf-8>");
            ps.println("<title>");
            ps.println("jeunesse的网页");
            ps.println("</title>");
            ps.println("</head>");
            ps.println("<body>");
            ps.println("<h1 style='color:red';font-size=20px>看jeunesse的网页</h1>");
            ps.println("</body>");
            ps.println("</html>");
            ps.close();
            socket.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("客户端断开了");
        }
    }
}
```

**每次请求都开一个新线程，到底好不好？**

高并发时，容易宕机！

使用线程池进行优化

**代码**

`ServerDemo`

```java
// 目标：BS架构的原理理解
        System.out.println("服务端启动了...");
        // 1、创建服务端ServerSocket对象，绑定端口号，监听客户端连接
        ServerSocket ss = new ServerSocket(8080);

        // 创建线程池
        ExecutorService pool = new ThreadPoolExecutor(3,10,10, TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(100), Executors.defaultThreadFactory(),  new ThreadPoolExecutor.AbortPolicy());

        while (true) {
            // 2、调用accept方法，阻塞等待客户端连接，一旦有客户端链接会返回一个Socket对象
            Socket socket = ss.accept();
            System.out.println("一个客户端上线了..." + socket.getInetAddress().getHostAddress());
            // 3、把这个客户端管道包装成一个任务交给线程池处理
            pool.execute(new ServerReaderRunnable(socket));
        }
```

`ServerRunnable`

```java
public class ServerReaderRunnable implements Runnable {
    private Socket socket;
    public ServerReaderRunnable(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            // 给当前对应的浏览器管道响应一个网页数据回去
            OutputStream os =  socket.getOutputStream();
            // 通过字节输出流包装写出去数据给浏览器
            // 把字节输出流包装成打印流
            PrintStream ps = new PrintStream(os);
            // 写网页数据回去
            ps.println("HTTP/1.1 200 OK");
            ps.println("Content-Type:text/html;charset=utf-8");
            ps.println(); // 必须要换一行
            ps.println("<html>");
            ps.println("<head>");
            ps.println("<meta charset=utf-8>");
            ps.println("<title>");
            ps.println("jeunesse的网页");
            ps.println("</title>");
            ps.println("</head>");
            ps.println("<body>");
            ps.println("<h1 style='color:red';font-size=20px>看jeunesse的网页</h1>");
            ps.println("</body>");
            ps.println("</html>");
            ps.close();
            socket.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("客户端断开了");
        }
    }
}
```

## 第四节 实战项目-即时通讯

### 1.项目介绍，前置知识讲解

**时间相关的获取方案**

LocalDate：代表本地日期（年、月、日、星期）

LocalTime：代表本地时间（时、分、秒、纳秒）

LocalDateTime：代表本地日期、时间（年、月、日、星期、时、分、秒、纳秒）

**它们获取对象的方案**

| 方法名                                                   | 示例                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| `public static Xxxx now(): 获取系统当前时间对应的该对象` | `LocalDate ld = LocalDate.now();` `LocalTime lt = LocalTime.now();` `LocalDateTime ldt = LocalDateTime.now();` |

**LocalDateTimel的常用API(可以处理年、月、日、星期、时、分、秒、纳秒等信息)**

| 方法名                                                       | 说明                                      |
| ------------------------------------------------------------ | ----------------------------------------- |
| `getYear`、`getMonthValue`、`getDayOfMonth`、`getDayOfYear` `getDayOfWeek`、`getHour`、`getMinute`、`getSecond`、`getNano` | 获取年月日、时分秒、纳秒等                |
| `withYear`、`withMonth`、`withDayOfMonth`、`withDayOfYear` `withHour`、`withMinute`、`withSecond`、`withNano` | 修改某个信息，返回新日期时间对象          |
| `plusYears`、`plusMonths`、`plusDays`、`plusWeeks` `plusHours`、`plusMinutes`、`plusSeconds`、`plusNanos` | 把某个信息加多少，返回新日期时间对象      |
| `minusYears`、`minusMonths`、`minusDays`、`minusWeeks` `minusHours`、`minusMinutes`、`minusSeconds`、`minusNanos` | 把某个信息减多少，返回新日期时间对象      |
| `equals`、`isBefore`、`isAfter`                              | 判断 2 个时间对象，是否相等，在前还是在后 |

**代码**

```java
// 目标：掌握java提供的获取时间的方案
        // JDK 8之前的方案：Date 获取此刻日期时间 老项目还有
        Date d = new Date();
        System.out.println(d);

        // 格式化：SimpleDateFormat简单日期格式化，格式化日期对象成为我们喜欢的格式
        SimpleDateFormat  sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss EEE a");
        String result = sdf.format(d);
        System.out.println(result);

        // JDK 8之后的方案：LocalDate LocalTime LocalDateTime 获取此刻日期时间 新项目推荐
        // 获取此刻日期时间对象
        LocalDateTime now = LocalDateTime.now();
        System.out.println(now);
        System.out.println(now.getYear());
        System.out.println(now.getDayOfYear());

        // 格式化：DateTimeFormatter
        // 1、创建一个格式化对象
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss EEE a");
        // 格式化now对象的时间
        String result2 = dtf.format(now);
        System.out.println(result2);
```

**StringBuilder**

StringBuilder代表可变字符串对象，相当于是一个容器，它里面装的字符串是可以改变的，就是用来操作字符串的

好处：StringBuilderl比String更适合做字符串的修改操作，效率会更高，代码也会更简洁

| 构造器                             | 说明                                           |
| ---------------------------------- | ---------------------------------------------- |
| `public StringBuilder()`           | 创建一个空白的可变的字符串对象，不包含任何内容 |
| `public StringBuilder(String str)` | 创建一个指定字符串内容的可变字符串对象         |

| 方法名称                                | 说明                                                      |
| --------------------------------------- | --------------------------------------------------------- |
| `public StringBuilder append(任意类型)` | 添加数据并返回 StringBuilder 对象本身                     |
| `public StringBuilder reverse()`        | 将对象的内容反转                                          |
| `public int length()`                   | 返回对象内容长度                                          |
| `public String toString()`              | 通过 toString () 就可以实现把 StringBuilder 转换为 String |

**代码**

```java
// 目标：高效拼接字符串
        // + 号拼接字符串内容，如果是大量拼接，效率极差！
        // String的对象是不可变变量：共享数据性能可以，但是修改数据性能差！
//        String s = "";
//        for (int i = 0; i < 100000; i++) {
//            s = s + "abc";
//        }
//        System.out.println(s);

        // 定义字符串可以使用String类型，但是操作字符串建议大家用StringBuilder（性能好）
        StringBuilder sb = new StringBuilder(); // StringBuilder对象是可变内容的容器 sb = "";
        for (int i = 0; i < 100000; i++){
            sb.append("abc");
        }
        System.out.println(sb);
        // StringBuilder只是拼接字符串的手段，结果还是要恢复成字符串（目的）
        String s = sb.toString();
        System.out.println(s);

        StringBuilder sb2 = new StringBuilder();
        String result = sb2.append("张三").append("李四").append("王五").toString();
        System.out.println(result);
```

**BigDecimall的常见构造器、常用方法**

| 构造器                                                   | 说明                        |
| -------------------------------------------------------- | --------------------------- |
| `public BigDecimal(double val)` **注意：不推荐使用这个** | 将 double 转换为 BigDecimal |
| `public BigDecimal(String val)`                          | 把 String 转成 BigDecimal   |

| 方法名                                                       | 说明                          |
| ------------------------------------------------------------ | ----------------------------- |
| `public static BigDecimal valueOf(double val)`               | 转换一个 double 成 BigDecimal |
| `public BigDecimal add(BigDecimal b)`                        | 加法                          |
| `public BigDecimal subtract(BigDecimal b)`                   | 减法                          |
| `public BigDecimal multiply(BigDecimal b)`                   | 乘法                          |
| `public BigDecimal divide(BigDecimal b)`                     | 除法                          |
| `public BigDecimal divide (另一个BigDecimal对象, 精确几位, 舍入模式)` | 除法、可以控制精确到小数几位  |
| `public double doubleValue()`                                | 将 BigDecimal 转换为 double   |

**代码**

```java
// 目标：掌握BigDecimal解决小数运算结果失真问题
        double a = 0.1;
        double b = 0.2;
        System.out.println(a + b); // 0.30000000000000004

        // 如何解决呢？使用BigDecimal
        // 1、把小数包装成BigDecimal对象来运算才可以
        // 必须使用public BigDecimal(String val)字符串构造器才能解决失真问题
//        BigDecimal a1 = new BigDecimal(Double.toString(a));
//        BigDecimal b1 = new BigDecimal(Double.toString(b));

        // 优化方案，可以直接调用valveOf方法，内部使用的就是public BigDecimal(String val)字符串构造器
        BigDecimal a1 = BigDecimal.valueOf(a);
        BigDecimal b1 = BigDecimal.valueOf(b);
        BigDecimal c1 = a1.add(b1); // 解决精度问题的手段
        double result = c1.doubleValue(); // 目的 把BigDecimal对象转成double类型
        System.out.println(result);

        BigDecimal i = BigDecimal.valueOf(0.1);
        BigDecimal j = BigDecimal.valueOf(0.3);
        // 除法
        BigDecimal k = i.divide(j, 2, RoundingMode.FLOOR); // 抛异常
        System.out.println(k);
```

### 2.项目实现思路分析

**需求**

展示一个用户的登录界面，这个界面只要求用户输入自己聊天的呢称就可以了

登录进入后，展示一个群聊的窗口，这个窗口，展示在线人数，展示消息展示框，消息输入框，发送按钮。可以实现群聊。实现实时展示在线人数。完全做到即时通讯功能

**技术选型**

1. GUI界面编程
2. 网络通信
3. 面向对象编程
4. 各种API

**思路分析**

1. 创建一个模块，代表我们的项目：jeunesse-chat-system

2. 拿到系统需要的界面：Swing的代码

   -- 登录界面：这个界面只要求用户输入自己聊天的呢称就可以了

   ```java
   package com.jeunesse.ui;
   
   import javax.swing.*;
   import java.awt.*;
   
   public class ChatEntryFrame extends JFrame {
       private JTextField nicknameField;
       private JButton enterButton;
       private JButton cancelButton;
   
       public ChatEntryFrame() {
           setTitle("局域网聊天室");
           setSize(350, 150);
           setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
           setLocationRelativeTo(null);
           setResizable(false); // 禁止调整大小
   
           // 设置背景颜色
           getContentPane().setBackground(Color.decode("#F0F0F0"));
   
           //创建主面板并设置布局
           JPanel mainPanel = new JPanel(new BorderLayout());
           mainPanel.setBackground(Color.decode("#F0F0F0"));
           add(mainPanel);
   
           //创建顶部面板
           JPanel topPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
           topPanel.setBackground(Color.decode("#F0F0F0"));
   
           // 标签和文本框
           JLabel nicknameLabel = new JLabel("昵称：");
           nicknameLabel.setFont(new Font("楷体", Font.BOLD, 16));
           nicknameField = new JTextField(10);
           nicknameField.setFont(new Font("楷体", Font.PLAIN, 16));
           nicknameField.setBorder(BorderFactory.createCompoundBorder(
                   BorderFactory.createMatteBorder(1, 1, 1, 1, Color.GRAY),
                   BorderFactory.createEmptyBorder(5, 5, 5, 5)
           ));
   
           topPanel.add(nicknameLabel);
           topPanel.add(nicknameField);
           mainPanel.add(topPanel, BorderLayout.NORTH);
   
           // 按钮面板
           JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
           buttonPanel.setBackground(Color.decode("#F0F0F0"));
   
           enterButton = new JButton("进入");
           enterButton.setFont(new Font("楷体", Font.BOLD, 16));
           enterButton.setBackground(Color.decode("#007BFF"));
           enterButton.setForeground(Color.WHITE);
           enterButton.setBorderPainted(false);
           enterButton.setFocusPainted(false);
   
           cancelButton = new JButton("取消");
           cancelButton.setFont(new Font("楷体", Font.BOLD, 16));
           cancelButton.setBackground(Color.decode("#DC3545"));
           cancelButton.setForeground(Color.WHITE);
   
           buttonPanel.add(enterButton);
           buttonPanel.add(cancelButton);
           mainPanel.add(buttonPanel, BorderLayout.SOUTH);
   
           // 添加监听器
           enterButton.addActionListener(e -> {
               String nickname = nicknameField.getText();
               if (!nickname.isEmpty()) {
                   // 进入聊天室逻辑
                   dispose(); // 关闭窗口
               } else {
                   JOptionPane.showMessageDialog(this, "请输入昵称！");
               }
           });
   
           cancelButton.addActionListener(e -> System.exit(0));
   
           this.setVisible(true);
       }
   
       public static void main(String[] args) {
           new ChatEntryFrame();
       }
   }
   ```

   -- 获取系统需要的聊天界面

   ```java
   package com.jeunesse.ui;
   
   import javax.swing.*;
   import java.awt.*;
   import java.awt.event.ActionEvent;
   import java.awt.event.ActionListener;
   
   public class ClientChatFrame extends JFrame {
       public JTextArea smsContent = new JTextArea(23, 50);
       private JTextArea smsSend = new JTextArea(4, 40);
       public JList<String> onLineUsers = new JList<>();
       private JButton sendBn = new JButton("发送");
   
       public ClientChatFrame() {
           initView();
           this.setVisible(true);
       }
   
       private void initView() {
           this.setSize(700, 600);
           this.setLayout(new BorderLayout());
           this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 关闭窗口，退出程序
           this.setLocationRelativeTo(null); // 窗口居中
   
           // 设置窗口背景色
           this.getContentPane().setBackground(new Color(0xf0, 0xf0, 0xf0));
   
           // 设置字体
           Font font = new Font("SimKai", Font.PLAIN, 14);
   
           // 消息内容框
           smsContent.setFont(font);
           smsContent.setBackground(new Color(0xdd, 0xdd, 0xdd));
           smsContent.setEditable(false);
   
           // 发送消息框
           smsSend.setFont(font);
           smsSend.setWrapStyleWord(true);
           smsSend.setLineWrap(true);
   
           // 在线用户列表
           onLineUsers.setFont(font);
           onLineUsers.setFixedCellWidth(120);
           onLineUsers.setVisibleRowCount(13);
   
           // 创建底部面板
           JPanel bottomPanel = new JPanel(new BorderLayout());
           bottomPanel.setBackground(new Color(0xf0, 0xf0, 0xf0));
   
           // 消息输入框
           JScrollPane smsSendScrollPane = new JScrollPane(smsSend);
           smsSendScrollPane.setBorder(BorderFactory.createEmptyBorder());
           smsSendScrollPane.setPreferredSize(new Dimension(500, 50));
   
           // 发送按钮
           sendBn.setFont(font);
           sendBn.setBackground(Color.decode("#009688"));
           sendBn.setForeground(Color.WHITE);
   
           // 按钮面板
           JPanel btns = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 5));
           btns.setBackground(new Color(0xf0, 0xf0, 0xf0));
           btns.add(sendBn);
   
           // 添加组件
           bottomPanel.add(smsSendScrollPane, BorderLayout.CENTER);
           bottomPanel.add(btns, BorderLayout.EAST);
   
           // 用户列表面板
           JScrollPane userListScrollPane = new JScrollPane(onLineUsers);
           userListScrollPane.setBorder(BorderFactory.createEmptyBorder());
           userListScrollPane.setPreferredSize(new Dimension(120, 500));
   
           // 中心消息面板
           JScrollPane smsContentScrollPane = new JScrollPane(smsContent);
           smsContentScrollPane.setBorder(BorderFactory.createEmptyBorder());
   
           // 添加所有组件
           this.add(smsContentScrollPane, BorderLayout.CENTER);
           this.add(bottomPanel, BorderLayout.SOUTH);
           this.add(userListScrollPane, BorderLayout.EAST);
       }
   
       public static void main(String[] args) {
           new ClientChatFrame();
       }
   }
   ```

3. 定义一个APP启动类：创建进入界面对象并展示
   ```java
   import com.jeunesse.ui.ClientChatFrame;
   
   public class App {
       public static void main(String[] args) {
           new ClientChatFrame();
       }
   }
   ```

4. 分析系统的整体架构
   1、开发服务端要做的事情大概有这些
   -- 接收客户端的管道链接

   -- 接收登录消息，接收呢称信息

   -- 服务端也可能是接收客户端发送过来的群聊消息 

   -- 服务端存储全部在线的socket管道，以便到时候知道哪些客户端在线，以便为这些客户端转发消息

   -- 如果服务端收到了登录消息，接收呢称，然后更新所有客户端的在线人数列表

   -- 如果服务端收到了群聊消息，需要接收这个人的消息，再转发给所有客户端展示这个消息
   2、客户端界面已经准备好了

5. 先开发完整的服务端

   第一步：创建一个服务端的项目：jeunesse-chat-server
   第二步：创建一个服务端启动类，启动服务器等待客户端的链接

   ```java
   public class Server {
       public static void main(String[] args) {
           System.out.println("启动服务端系统.....");
           try {
               // 1、注册端口
               ServerSocket serverSocket = new ServerSocket(Constant.PORT);
               // 2、主线程负责接受客户端的连接请求
               while (true) {
                   // 3、调用accept方法，获取到客户端的Socket对象
                   System.out.println("等待客户端的连接.....");
                   Socket socket = serverSocket.accept();
                   System.out.println("客户端连接成功.....");
               }
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   }
   ```

   第三步：把这个管道交给一个独立的线程来处理：以便支持很多客户端可以同时进来通信

   ```java
   public class Server {
       public static void main(String[] args) {
           System.out.println("启动服务端系统.....");
           try {
               // 1、注册端口
               ServerSocket serverSocket = new ServerSocket(Constant.PORT);
               // 2、主线程负责接受客户端的连接请求
               while (true) {
                   // 3、调用accept方法，获取到客户端的Socket对象
                   System.out.println("等待客户端的连接.....");
   
                   Socket socket = serverSocket.accept();
                   new ServerReaderThread(socket).start();
                   
                   System.out.println("客户端连接成功.....");
               }
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   }
   ```

   第四步：定义一个集合容器存储所有登录进来的客户端管道，以便将来群发消息给他们
   -- 这个集合只需要一个，记住所有的在线的客户端socket

   ```java
   // 定义一个Map集合，键是存储客户端的管道，值是这个管道的用户名称、
       public static final Map<Socket, String> map = new HashMap<>();
   ```

   第五步：服务端接收登录消息/群聊消息
   先接收一个整数，再判断，再区别对待

   第六步：实现服务端的登录消息接收
   ```java
   package com.jeunesse;
   
   import java.io.DataInputStream;
   import java.io.DataOutputStream;
   import java.io.InputStream;
   import java.net.Socket;
   import java.util.Collection;
   
   public class ServerReaderThread extends Thread{
       private Socket socket;
       public ServerReaderThread(Socket socket) {
           this.socket = socket;
       }
   
       @Override
       public void run() {
           try {
               // 接收的消息可能有很多种类型：1、登录消息（包含呢称） 2、群聊消息 3、私聊消息
               // 所以客户端必须声明协议发送消息
               // 比如客户端先发1，代表接下来是登录消息。
               // 比如客户端先发2，代表接下来是群聊消息。
               // 先从socket管道中接收客户端发送来的消息类型编号
               DataInputStream dis = new DataInputStream(socket.getInputStream());
               int type = dis.readInt(); // 1、2、3代表三种消息类型
               switch (type) {
                   case 1:
                       // 客户端发来了登录消息，接下来要接收呢称数据，再更新全部在线客户端的在线人数列表
                       String nickName = dis.readUTF();
                       // 把这个登录成功的客户端socket存入到在线集合
                       Server.onLineSockets.put(socket, nickName);
                       // 更新全部客户端的在线人数列表
                       updateClientonLineUserList();
                       break;
                   case 2:
                       // 客户端发来了群聊消息，接下来要接收群聊消息内容，再把群聊消息转发给全部在线客户端
                       break;
                   case 3:
                       // 客户端发来了私聊消息，接下来要接收私聊消息内容，再把私聊消息转发给指定的在线客户端
                       break;
               }
           } catch (Exception e) {
               System.out.println("客户端下线了" + socket.getInetAddress().getHostAddress());
               Server.onLineSockets.remove(socket); // 把下线的客户端Socket从在线集合中移出
           }
       }
   
       private void updateClientonLineUserList() {
           // 更新全部客户端的在线人数列表
           // 拿到全部在线客户端的用户名称，把这些名称转发给全部在线s0ckt管道
           // 1、拿到全部在线客户端的用户名称
           Collection<String> onLineUsers = Server.onLineSockets.values();
           // 2、把这个集合中的所有用户都推送给全部客户端Socket管道
           for (Socket socket : Server.onLineSockets.keySet()) {
               try {
                   // 3、把用户名称集合发送给每一个Socket管道
                   DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
                   dos.writeInt(1); // 1 代表是客户端接下来是在线人数列表消息 2 代表是群聊消息
                   dos.writeInt(onLineUsers.size()); // 告诉客户端，接下来要发多少个用户名称
                   for (String user : onLineUsers) {
                       dos.writeUTF(user);
                   }
                   dos.flush();
               } catch (Exception e) {
                   e.printStackTrace();
               }
           }
       }
   }
   
   ```

   第七步：接收客户端的群聊消息
   线程每收一个客户端的群聊消息，就应该把这个消息转发给全部在线的客户端对应的socket管道

   ```java
   package com.jeunesse;
   
   import java.io.DataInputStream;
   import java.io.DataOutputStream;
   import java.io.InputStream;
   import java.net.Socket;
   import java.time.LocalDateTime;
   import java.time.format.DateTimeFormatter;
   import java.util.Collection;
   
   public class ServerReaderThread extends Thread{
       private Socket socket;
       public ServerReaderThread(Socket socket) {
           this.socket = socket;
       }
   
       @Override
       public void run() {
           try {
               // 接收的消息可能有很多种类型：1、登录消息（包含呢称） 2、群聊消息 3、私聊消息
               // 所以客户端必须声明协议发送消息
               // 比如客户端先发1，代表接下来是登录消息。
               // 比如客户端先发2，代表接下来是群聊消息。
               // 先从socket管道中接收客户端发送来的消息类型编号
               DataInputStream dis = new DataInputStream(socket.getInputStream());
               while (true) {
                   int type = dis.readInt(); // 1、2、3代表三种消息类型
                   switch (type) {
                       case 1:
                           // 客户端发来了登录消息，接下来要接收呢称数据，再更新全部在线客户端的在线人数列表
                           String nickName = dis.readUTF();
                           // 把这个登录成功的客户端socket存入到在线集合
                           Server.onLineSockets.put(socket, nickName);
                           // 更新全部客户端的在线人数列表
                           updateClientonLineUserList();
                           break;
                       case 2:
                           // 客户端发来了群聊消息，接下来要接收群聊消息内容，再把群聊消息转发给全部在线客户端
                           String msg = dis.readUTF();
                           sendMsgToAll(msg);
                           break;
                       case 3:
                           // 客户端发来了私聊消息，接下来要接收私聊消息内容，再把私聊消息转发给指定的在线客户端
                           break;
                   }
               }
           } catch (Exception e) {
               System.out.println("客户端下线了" + socket.getInetAddress().getHostAddress());
               Server.onLineSockets.remove(socket); // 把下线的客户端Socket从在线集合中移出
               updateClientonLineUserList(); // 下线了用户也需要更新全部客户端的在线人数列表
           }
       }
   
       // 给全部在线socket推送当前客户端发来的消息
       private void sendMsgToAll(String msg) {
           // 一定要拼装好这个消息，再发给全部在线socket
           StringBuilder sb = new StringBuilder();
           String name = Server.onLineSockets.get(socket);
   
           // 获取当前时间
           LocalDateTime  now = LocalDateTime.now();
           DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss EEE");
           String nowStr = dtf.format(now);
   
           String msgResult = sb.append(name).append(" ").append(nowStr).append("\r\n")
                   .append(msg).append("\r\n").toString();
           // 推送给全部客户端socket
           for (Socket socket : Server.onLineSockets.keySet()) {
               try {
                   // 3、把用户名称集合发送给每一个Socket管道
                   DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
                   dos.writeInt(2); // 1 代表是客户端接下来是在线人数列表消息 2 代表是群聊消息
                   dos.writeUTF(msgResult);
                   dos.flush(); // 刷新数据！
               } catch (Exception e) {
                   e.printStackTrace();
               }
           }
       }
   
       private void updateClientonLineUserList() {
           // 更新全部客户端的在线人数列表
           // 拿到全部在线客户端的用户名称，把这些名称转发给全部在线s0ckt管道
           // 1、拿到全部在线客户端的用户名称
           Collection<String> onLineUsers = Server.onLineSockets.values();
           // 2、把这个集合中的所有用户都推送给全部客户端Socket管道
           for (Socket socket : Server.onLineSockets.keySet()) {
               try {
                   // 3、把用户名称集合发送给每一个Socket管道
                   DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
                   dos.writeInt(1); // 1 代表是客户端接下来是在线人数列表消息 2 代表是群聊消息
                   dos.writeInt(onLineUsers.size()); // 告诉客户端，接下来要发多少个用户名称
                   for (String user : onLineUsers) {
                       dos.writeUTF(user);
                   }
                   dos.flush();
               } catch (Exception e) {
                   e.printStackTrace();
               }
           }
       }
   }
   ```

6. 完善整个客户端程序的代码

   第一步： 从登录界面开始：完成了登录，完成了socket管道传给消息聊天界面

   给这个进入按钮绑定一个点击事件监听器，让他可以点击，一旦点击了，获取到昵称，然后立即请求与服务器端的socket管道链接

   并立即发送登录信息：发送1，发送昵称

   再展示客户端的聊天界面：接收到了呢称，接收到了属于自己客户端的socketi通信管道

   第二步：立即在消息聊天界面，立即读取客户端socket管道从服务端发来的在线人数更新消息/群聊消息

   交给一个独立的线程专门负责读取客户端socket从服务端收到的在线人数更新数据和群聊数据

   收到消息，先判断消息的类型，判断是在线人数更新消息还是群聊消息，分开处理

   第三步：接收群聊消息

   接收消息类型2，接收群聊数据，展示到界面的面板上去即可

   第四步：发送群聊消息

   给发送按钮绑定一个点击事件，获取输入框的消息内容，再先发送2，再把群聊内容发送给服务端就完事了

