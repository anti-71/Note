# 第二章 数据的表示和运算

## 2.1 数制与编码

### 2.1.1 进位计数制及其相互转换

采用二进制编码的原因：

​	1）使用有两个稳定状态的物理器件即可表示

​	2）1和0正好与逻辑值”真“和”假“相对应以实现逻辑运算

​	3）可用逻辑门电路方便的实现算术运算

#### 1.进位计数制

**基数**：每个数位用到的不同数码的个数，r进制基数为r

每个数位的数值等于该数码乘以一个常数，这个常数叫**位权**

后缀字母**B**表示二进制数，**O**表示八进制数，**D**表示十进制数，**H**表示十六进制数，也用前缀0x表示

#### 2.不同进制数之间的转换

- 二进制→八进制和十六进制

对于整数部分，每3位或4位一组，最左边可加“0”补齐

对于小数部分，也每3位或4位一组，最右边可加“0”补齐

- 八进制和十六进制→二进制

每位改为3位或4位二进制数

- 任意进制→十进制

各位数码与它们的权值相乘，再把乘积相加，这叫**按权展开相加法**

- 十进制→任意进制

对于整数部分，采用**基数乘除法**，除基取余，先余为低，后余为高

对于小数部分，采用**乘基取整法**，乘基取整，先整为高，后整为低

> 在计算机中，整数可连续表示，但小数是离散的，所以并不是每个十进制小数都可准确的用二进制小数表示

### 2.1.2 定点数的编码表示

#### 1.真值和机器数

**真值**：带“+”或“-”符号的数

**机器数**：在计算机中，将数据的符号数字化，用“0”表示“正”，用“1”表示“负“

#### 2.机器数的定点表示

根据小数点的位置是否固定，两种数据格式：定点表示和浮点表示（科学计数法）

定点表示法：

​	1）定点小数：纯小数

​	2）定点整数：纯整数

#### 3.原码、补码、反码、译码

- 原码表示法

用机器数最高位表示数的符号，其余各位表示数的绝对值

字长为n+1，尾数占n位，原码整数的表示范围为$-(2^n-1)\leq x\leq 2^n-1$，原码小数的表示范围为$-(1-2^{-n})\leq x\leq 2^n-1$

> 0的原码表示有正零和负零

- 补码表示法

正数的补码和原码相同，负数的补码等于模（n+1位补码的模为$2^{n+1}$）与该负数的绝对值之差

字长为n+1，补码整数的表示范围为$-2^n\leq x\leq 2^n-1$（比原码多“$-2^n$”，补码小数的表示范围为$-1\leq x\leq 2^n-1$（比原码多“-1”）

0的补码表示是唯一的

$[x]_补$求$[-x]_补$：符号位、数值位全取反，末位+1

**模运算**：一个数与它除以“模”后得到的余数是等价的，$A=B+K×M$记为$A\equiv B(modM)$，补码可以借助假发运算实现减法运算

补码与真值之间的转换：

​	真值转换成补码：正数，与原码一样；负数，符号位取1，其余各位“按位取反，末位加1”

​	补码转化为真值：符号位为0，与原码一样；符号位为1，真值符号为负，数值“按位取反，末位加1”

**变形补码**：判断结果是否溢出，采用双符号位，所以也叫**模4补码**。在双符号位中，左符是真正的符号位，右符用来判断溢出

- 反码表示法

正数，与原码相同；负数，仅“按位取反”而末位不加1

存在$\pm0$

- 移码表示法

只能用来表示整数

移码是在补码的基础上将符号位取反

字长为n+1，表示范围为$-(2^n-1)\leq x\leq 2^n-1$

零的表示唯一

移码大真值就大，移码小真值就小

一般用移码表示浮点数的阶码，而补码表示定点整数

- 4种编码表示的总结
  - 原码、补码、反码符号位相同，正数机器码相同
  - 原码、反码在数轴上对称，都存在$\pm 0$
  - 补码、移码在数轴上不对成，0的表示唯一，比原码、反码多表示一个数
  - 原码容易判断大小。而负数的补码、反码很难直接比较，采用：负数，数值位越小，绝对值越大

### 2.1.3 整数的表示

#### 1.无符号整数的表示

**无符号整数**：二进制位全为数值位没有符号位

可用无符号整数进行地址运算或表示指针

#### 2.有符号整数的表示

**有符号整数**：将符号数值化，放在有效数字前面

补码的优势：

​	1）0的表示唯一

​	2）运算规则简单，符号位可参与运算

​	3）比原码、反码多表示一个最小负数

### 2.1.4 C语言中的整数类型及类型转换

#### 1.C语言中的整数数据类型

有符号整数：短整型（short或short int，16位）、整形（int，32位）、长整型（long或long int，32位机器中32位，64位机器中64位）

无符号整数：前面加关键字unsigned，短整型（unsigned short或unsigned short int）、无符号整型（unsigned int）、无符号长整形（unsigned long或unsigned long int）

若不指定signed/unsigned时，则默认为有符号整数

字符型（char，8位），默认按无符号整数解释

上述类型皆以补码形式储存

#### 2.有符号数和无符号数的转换

short型强制转换为unsigned short型：不改变数据内容，改变解释方式

unsigned型强制转换为unsigned short型：符号扩展

>同时有有符号整数和无符号整数参与运算，C语言标准规定按无符号整数运算

#### 3.不同字长整数之间的转换

为什么要进行位数转换？

​	ALU的位数固定，运算前可能需要转换

​	通用寄存器位数固定，存入数据时可能需要长度扩展

​	主存内各种数据查长度不一，有时需要把短数据扩展为长数据

大字长→小字长：高位截断，低位保留

小字长→大字长：无符号整数，进行**零扩展**，高位部分用0填充；有符号整数，进行**符号扩展**，高位部分用原数字符号位填充

## 2.2 运算方法和运算电路

### 2.2.1 基本运算部件

#### 1.一位全加器

**全加器（FA)**有加数$A_i$、$B_i$和低位传来的进位$C_{i-1}$三个输入，有本位和$S_i$及向高位进位$C_i$两个输出

和表达式：$S_i=A_i\oplus B_i\oplus C_{i-1}$

进位表达式：$C_i=A_iB_i+(A_i\oplus B_i)C_{i-1}$

<img src="D:\Note\考研\计算机组成原理\Assets\一位全加器.png" style="zoom: 50%;" />

#### 2.串行进位加法器

将n个全加器相连可得到n位加法器，称为**串行进位加法器**，也称**行波进位**，即进位信号是逐级形成的

#### *3.并行进位加法器

并行进位（也称先行进位），需要将n个一位全加器连接上n位先行进位部分（简称CLA部件），其作用是“并行产生进位”

#### 4.带标志加法器

**溢出标志**$OF=C_n\oplus C_{n-1}$，判断**有符号数**的加减运算是否溢出，$OF=0$表示未溢出，$OF=1$表示溢出

**符号标志**$SF=F_{n-1}$，表示**有符号数**的加减运算结果的正负性，$SF=0$表示结果为正，$SF=1$表示结果为负

**零标志**$ZF=\overline{S_n+...+S_2+S_1}$，表示加减运算的结果是否为0，$ZF=0$表示结果非0，$ZF=1$表示结果为0

**进位/借位标志**$CF=C_{out}\oplus C_{in}$，判断**无符号数**的加减运算是否发生溢出，$CF=0$表示未溢出，$CF=1$表示溢出

#### 5.算数逻辑单元（ALU）

ALU是一种功能较强的组合逻辑电路，能进行多种算术运算和逻辑运算

ALU是运算器的核心，ALU的核心是带标志加法器

若支持k种功能，ALUop位数$\geq\lceil \log_{2}k\rceil$

ALU运算数、运算结果位数与计算机的机器字长相同

标志信息送入PSW程序状态寄存器（有的也称标志寄存器FR）

![](D:\Note\考研\计算机组成原理\Assets\ALU的基本结构.jpg)

### 2.2.2 定点数的移位运算

左移一位，相当于乘以基数；右移一位，相当于除以基数

由于原、反、补码位数有限，因此某些时候算术移位不能精确等效乘除法

#### 1.逻辑移位

将操作数视为无符号整数

#### 2.算术移位

将操作数视为有符号整数

原码算术移位：符号位保持不变，仅对数值位进行移位

反码算术移位：正数与原码相同，负数移位补1

补码算术移位：正数与原码相同
				   负数右移：高位补1，低位舍弃；左移：低位补0，高位舍弃

#### 3.循环移位

不带进位位：用移出的位补上空缺

带进位位：移出的位放到进位位，原进位位补上空缺

#### 4.溢出和丢失精度

对于**无符号整数**，若高位移出1，则溢出；若低位移出1，则丢失精度

对**有符号整数**，若左移前后符号位不同，则溢出；若低位移出1，则丢失精度

### 2.2.3 定点数的加减运算

#### 1.补码的加减运算

$$
[A+B]_补=[A]_补+[B]_补(mod2^{n+1})\\
[A-B]_补=[A]_补+[-B]_补(mod2^{n+1})
$$

1. 符号位与数值位一起参与运算

2. 最终结果的高位丢弃，保留n+1位
   >求补：从右往左第一个1的左边取反
   >
   >求相反数的补：连同符号位一起取反

#### 2.溢出判别方法

**上溢**：两个正数相加，符号位为1

**下溢**：一个负数减去一个正数，符号位为0

1）采用一位符号位

​	溢出逻辑表达式
$$
V=A_sB_s\overline{S_s}+\overline{A_s}\overline{B_s}S_s
$$
​	若V=0，无溢出；若V=1，有溢出

2）采用双符号位

​	实际只存储一个符号位，运算时复制符号位

​	溢出逻辑表达式
$$
V=S_{s1}\oplus S_{s2}
$$
​	若V=0,无溢出；V=1，有溢出

3）采用一位符号位根据数值为的进位情况判断溢出

​	溢出逻辑表达式
$$
V=C_n\oplus C_{n-1}
$$
​	若V=0,无溢出；V=1，有溢出

#### 3.加减运算电路

控制器Sub以选择是将$Y$输入加法器还是将$\overline{Y}$输入加法器，并将Sub同时作为低位进位送到加法器（做减法时实现末位加1）

<img src="D:\Note\考研\计算机组成原理\Assets\加减运算部件.png" style="zoom:50%;" />

> 运算器本身不能识别是否有符号

#### 4.无符号数加减运算

1. 实现原理
   	加法：从最低位开始，按位相加，并向更高位进位
   	减法：被减数不变，减数按位取反，末位加1，相加

2. 溢出判断：

   ​	加法：最高位进位=1，溢出
   ​	减法：最高位进位=0，溢出

3. 溢出手算判断：n bit无符号整数表示范围为$0\sim2^n-1$，超出此范围则溢出

### 2.2.4 定点数的乘除运算

#### 1.定点乘法运算

1）乘法运算的基本原理

​	乘法运算可用加法和移位运算来实现，符号位为$x_s\oplus y_s$

​	部分积$P_i$是乘法运算的中间结果，初值$P_0=0$。从乘数最低位$y_n$开始，将前面的部分积$P_i$加上$X×y_{n-i}$，然后右移一位，此步骤重复n次

> 右移均为逻辑右移

2）乘法运算电路

​	乘积寄存器P开始时置0

<img src="D:\Note\考研\计算机组成原理\Assets\32位无符号数乘法运算的逻辑结构图.png" style="zoom:50%;" />

3）补码一位乘法

​	符号位、数值位都是由被乘数和乘数进行n轮加法、移位，最后多来一次加法

​	每次加法可能+0、+$[x]_补$、+$[-x]_补$

​	每次移位都是“补码的算数右移”

​	乘数的符号位参与运算

​	多一个辅助位（开始时扩展一个0）：为1，部分积+$[x]_补$；为0，部分积+0；为-1，部分积+$[-x]_补$

#### 2.除法运算

1）除法运算的基本原理

​	符号位为$x_s\oplus y_s$

​	被除数（余数）与除数相减，够减商1，不够减商0

​	每次得到的差为中间余数，逻辑左移1位，重复上一步

​	最后的余数若符号位为1，再恢复一次余数

2）除法运算电路

​	每次循环，寄存器R和Q同步左移

​	每次默认上商1，再根据余数符号位是否为1来决定是否回复余数

<img src="D:\Note\考研\计算机组成原理\Assets\32位除法逻辑结构图.png" style="zoom:67%;" />

3）补码除法

​	符号位参与运算，被除数/余数、除数采用双符号位

​	被除数和除数同号，则被除数减去除数；异号，则被除数加除数

​	余数和除数同号，商1，余数左移1位减除数；异号，商0，余数左移一位加除数；重复n次

​	末位商恒置1
![](D:\Note\考研\计算机组成原理\Assets\除法运算总结.png)
